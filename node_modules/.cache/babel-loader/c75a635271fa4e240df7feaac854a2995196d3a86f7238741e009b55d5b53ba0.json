{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\nexport const WHITE = 'w';\nexport const BLACK = 'b';\nexport const PAWN = 'p';\nexport const KNIGHT = 'n';\nexport const BISHOP = 'b';\nexport const ROOK = 'r';\nexport const QUEEN = 'q';\nexport const KING = 'k';\nexport const DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q'\n};\n// prettier-ignore\nexport const SQUARES = ['a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8', 'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7', 'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6', 'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5', 'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4', 'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3', 'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2', 'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'];\nconst BITS = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64\n};\n/*\r\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\r\n * ----------------------------------------------------------------------------\r\n * From https://github.com/jhlywa/chess.js/issues/230\r\n *\r\n * A lot of people are confused when they first see the internal representation\r\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\r\n * stores the board as an 8x16 array. This is purely for efficiency but has a\r\n * couple of interesting benefits:\r\n *\r\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\r\n *    square with 0x88, if the result is non-zero then the square is off the\r\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\r\n *    there are 8 possible directions in which the knight can move. These\r\n *    directions are relative to the 8x16 board and are stored in the\r\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\r\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\r\n *    (because of two-complement representation of -18). The non-zero result\r\n *    means the square is off the board and the move is illegal. Take the\r\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\r\n *    means the square is on the board.\r\n *\r\n * 2. The relative distance (or difference) between two squares on a 8x16 board\r\n *    is unique and can be used to inexpensively determine if a piece on a\r\n *    square can attack any other arbitrary square. For example, let's see if a\r\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\r\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\r\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\r\n *    bitmask of pieces that can attack from that distance and direction.\r\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\r\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\r\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\r\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\r\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\r\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\r\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\r\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\r\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n  a8: 0,\n  b8: 1,\n  c8: 2,\n  d8: 3,\n  e8: 4,\n  f8: 5,\n  g8: 6,\n  h8: 7,\n  a7: 16,\n  b7: 17,\n  c7: 18,\n  d7: 19,\n  e7: 20,\n  f7: 21,\n  g7: 22,\n  h7: 23,\n  a6: 32,\n  b6: 33,\n  c6: 34,\n  d6: 35,\n  e6: 36,\n  f6: 37,\n  g6: 38,\n  h6: 39,\n  a5: 48,\n  b5: 49,\n  c5: 50,\n  d5: 51,\n  e5: 52,\n  f5: 53,\n  g5: 54,\n  h5: 55,\n  a4: 64,\n  b4: 65,\n  c4: 66,\n  d4: 67,\n  e4: 68,\n  f4: 69,\n  g4: 70,\n  h4: 71,\n  a3: 80,\n  b3: 81,\n  c3: 82,\n  d3: 83,\n  e3: 84,\n  f3: 85,\n  g3: 86,\n  h3: 87,\n  a2: 96,\n  b2: 97,\n  c2: 98,\n  d2: 99,\n  e2: 100,\n  f2: 101,\n  g2: 102,\n  h2: 103,\n  a1: 112,\n  b1: 113,\n  c1: 114,\n  d1: 115,\n  e1: 116,\n  f1: 117,\n  g1: 118,\n  h1: 119\n};\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15]\n};\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1]\n};\n// prettier-ignore\nconst ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20];\n// prettier-ignore\nconst RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\nconst PIECE_MASKS = {\n  p: 0x1,\n  n: 0x2,\n  b: 0x4,\n  r: 0x8,\n  q: 0x10,\n  k: 0x20\n};\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\r\n * const RANK_3 = 5\r\n * const RANK_4 = 4\r\n * const RANK_5 = 3\r\n * const RANK_6 = 2\r\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n  [KING]: BITS.KSIDE_CASTLE,\n  [QUEEN]: BITS.QSIDE_CASTLE\n};\nconst ROOKS = {\n  w: [{\n    square: Ox88.a1,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h1,\n    flag: BITS.KSIDE_CASTLE\n  }],\n  b: [{\n    square: Ox88.a8,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h8,\n    flag: BITS.KSIDE_CASTLE\n  }]\n};\nconst SECOND_RANK = {\n  b: RANK_7,\n  w: RANK_2\n};\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n  return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n  return square & 0xf;\n}\nfunction isDigit(c) {\n  return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n  const f = file(square);\n  const r = rank(square);\n  return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n}\nfunction swapColor(color) {\n  return color === WHITE ? BLACK : WHITE;\n}\nexport function validateFen(fen) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/);\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields'\n    };\n  }\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10);\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer'\n    };\n  }\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10);\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: half move counter number must be a non-negative integer'\n    };\n  }\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: en-passant square is invalid'\n    };\n  }\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: castling availability is invalid'\n    };\n  }\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: side-to-move is invalid'\n    };\n  }\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/');\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\"\n    };\n  }\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0;\n    let previousWasNumber = false;\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)'\n          };\n        }\n        sumFields += parseInt(rows[i][k], 10);\n        previousWasNumber = true;\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)'\n          };\n        }\n        sumFields += 1;\n        previousWasNumber = false;\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)'\n      };\n    }\n  }\n  if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n    return {\n      ok: false,\n      error: 'Invalid FEN: illegal en-passant square'\n    };\n  }\n  const kings = [{\n    color: 'white',\n    regex: /K/g\n  }, {\n    color: 'black',\n    regex: /k/g\n  }];\n  for (const {\n    color,\n    regex\n  } of kings) {\n    if (!regex.test(tokens[0])) {\n      return {\n        ok: false,\n        error: `Invalid FEN: missing ${color} king`\n      };\n    }\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return {\n        ok: false,\n        error: `Invalid FEN: too many ${color} kings`\n      };\n    }\n  }\n  return {\n    ok: true\n  };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n  const from = move.from;\n  const to = move.to;\n  const piece = move.piece;\n  let ambiguities = 0;\n  let sameRank = 0;\n  let sameFile = 0;\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from;\n    const ambigTo = moves[i].to;\n    const ambigPiece = moves[i].piece;\n    /*\r\n     * if a move of the same piece type ends on the same to square, we'll need\r\n     * to add a disambiguator to the algebraic notation\r\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++;\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++;\n      }\n      if (file(from) === file(ambigFrom)) {\n        sameFile++;\n      }\n    }\n  }\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\r\n       * if there exists a similar moving piece on the same rank and file as\r\n       * the move in question, use the square as the disambiguator\r\n       */\n      return algebraic(from);\n    } else if (sameFile > 0) {\n      /*\r\n       * if the moving piece rests on the same file, use the rank symbol as the\r\n       * disambiguator\r\n       */\n      return algebraic(from).charAt(1);\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0);\n    }\n  }\n  return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n  const r = rank(to);\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i];\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION\n      });\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      flags\n    });\n  }\n}\nfunction inferPieceType(san) {\n  let pieceType = san.charAt(0);\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n    if (matches) {\n      return undefined;\n    }\n    return PAWN;\n  }\n  pieceType = pieceType.toLowerCase();\n  if (pieceType === 'o') {\n    return KING;\n  }\n  return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nexport class Chess {\n  _board = new Array(128);\n  _turn = WHITE;\n  _header = {};\n  _kings = {\n    w: EMPTY,\n    b: EMPTY\n  };\n  _epSquare = -1;\n  _halfMoves = 0;\n  _moveNumber = 0;\n  _history = [];\n  _comments = {};\n  _castling = {\n    w: 0,\n    b: 0\n  };\n  constructor(fen = DEFAULT_POSITION) {\n    this.load(fen);\n  }\n  clear(keepHeaders = false) {\n    this._board = new Array(128);\n    this._kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    this._turn = WHITE;\n    this._castling = {\n      w: 0,\n      b: 0\n    };\n    this._epSquare = EMPTY;\n    this._halfMoves = 0;\n    this._moveNumber = 1;\n    this._history = [];\n    this._comments = {};\n    this._header = keepHeaders ? this._header : {};\n    this._updateSetup(this.fen());\n  }\n  removeHeader(key) {\n    if (key in this._header) {\n      delete this._header[key];\n    }\n  }\n  load(fen, keepHeaders = false) {\n    let tokens = fen.split(/\\s+/);\n    // append commonly omitted fen tokens\n    if (tokens.length >= 2 && tokens.length < 6) {\n      const adjustments = ['-', '-', '0', '1'];\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n    }\n    tokens = fen.split(/\\s+/);\n    const {\n      ok,\n      error\n    } = validateFen(fen);\n    if (!ok) {\n      throw new Error(error);\n    }\n    const position = tokens[0];\n    let square = 0;\n    this.clear(keepHeaders);\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i);\n      if (piece === '/') {\n        square += 8;\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10);\n      } else {\n        const color = piece < 'a' ? WHITE : BLACK;\n        this.put({\n          type: piece.toLowerCase(),\n          color\n        }, algebraic(square));\n        square++;\n      }\n    }\n    this._turn = tokens[1];\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE;\n    }\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n    this._halfMoves = parseInt(tokens[4], 10);\n    this._moveNumber = parseInt(tokens[5], 10);\n    this._updateSetup(this.fen());\n  }\n  fen() {\n    let empty = 0;\n    let fen = '';\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n        const {\n          color,\n          type: piece\n        } = this._board[i];\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n      } else {\n        empty++;\n      }\n      if (i + 1 & 0x88) {\n        if (empty > 0) {\n          fen += empty;\n        }\n        if (i !== Ox88.h1) {\n          fen += '/';\n        }\n        empty = 0;\n        i += 8;\n      }\n    }\n    let castling = '';\n    if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n      castling += 'K';\n    }\n    if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n      castling += 'Q';\n    }\n    if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n      castling += 'k';\n    }\n    if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n      castling += 'q';\n    }\n    // do we have an empty castling flag?\n    castling = castling || '-';\n    let epSquare = '-';\n    /*\r\n     * only print the ep square if en passant is a valid move (pawn is present\r\n     * and ep capture is not pinned)\r\n     */\n    if (this._epSquare !== EMPTY) {\n      const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n      const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n      for (const square of squares) {\n        // is the square off the board?\n        if (square & 0x88) {\n          continue;\n        }\n        const color = this._turn;\n        // is there a pawn that can capture the epSquare?\n        if (this._board[square]?.color === color && this._board[square]?.type === PAWN) {\n          // if the pawn makes an ep capture, does it leave it's king in check?\n          this._makeMove({\n            color,\n            from: square,\n            to: this._epSquare,\n            piece: PAWN,\n            captured: PAWN,\n            flags: BITS.EP_CAPTURE\n          });\n          const isLegal = !this._isKingAttacked(color);\n          this._undoMove();\n          // if ep is legal, break and set the ep square in the FEN output\n          if (isLegal) {\n            epSquare = algebraic(this._epSquare);\n            break;\n          }\n        }\n      }\n    }\n    return [fen, this._turn, castling, epSquare, this._halfMoves, this._moveNumber].join(' ');\n  }\n  /*\r\n   * Called when the initial board setup is changed with put() or remove().\r\n   * modifies the SetUp and FEN properties of the header object. If the FEN\r\n   * is equal to the default position, the SetUp and FEN are deleted the setup\r\n   * is only updated if history.length is zero, ie moves haven't been made.\r\n   */\n  _updateSetup(fen) {\n    if (this._history.length > 0) return;\n    if (fen !== DEFAULT_POSITION) {\n      this._header['SetUp'] = '1';\n      this._header['FEN'] = fen;\n    } else {\n      delete this._header['SetUp'];\n      delete this._header['FEN'];\n    }\n  }\n  reset() {\n    this.load(DEFAULT_POSITION);\n  }\n  get(square) {\n    return this._board[Ox88[square]] || false;\n  }\n  put({\n    type,\n    color\n  }, square) {\n    // check for piece\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false;\n    }\n    // check for valid square\n    if (!(square in Ox88)) {\n      return false;\n    }\n    const sq = Ox88[square];\n    // don't let the user place more than one king\n    if (type == KING && !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n      return false;\n    }\n    this._board[sq] = {\n      type: type,\n      color: color\n    };\n    if (type === KING) {\n      this._kings[color] = sq;\n    }\n    this._updateCastlingRights();\n    this._updateEnPassantSquare();\n    this._updateSetup(this.fen());\n    return true;\n  }\n  remove(square) {\n    const piece = this.get(square);\n    delete this._board[Ox88[square]];\n    if (piece && piece.type === KING) {\n      this._kings[piece.color] = EMPTY;\n    }\n    this._updateCastlingRights();\n    this._updateEnPassantSquare();\n    this._updateSetup(this.fen());\n    return piece;\n  }\n  _updateCastlingRights() {\n    const whiteKingInPlace = this._board[Ox88.e1]?.type === KING && this._board[Ox88.e1]?.color === WHITE;\n    const blackKingInPlace = this._board[Ox88.e8]?.type === KING && this._board[Ox88.e8]?.color === BLACK;\n    if (!whiteKingInPlace || this._board[Ox88.a1]?.type !== ROOK || this._board[Ox88.a1]?.color !== WHITE) {\n      this._castling.w &= ~BITS.QSIDE_CASTLE;\n    }\n    if (!whiteKingInPlace || this._board[Ox88.h1]?.type !== ROOK || this._board[Ox88.h1]?.color !== WHITE) {\n      this._castling.w &= ~BITS.KSIDE_CASTLE;\n    }\n    if (!blackKingInPlace || this._board[Ox88.a8]?.type !== ROOK || this._board[Ox88.a8]?.color !== BLACK) {\n      this._castling.b &= ~BITS.QSIDE_CASTLE;\n    }\n    if (!blackKingInPlace || this._board[Ox88.h8]?.type !== ROOK || this._board[Ox88.h8]?.color !== BLACK) {\n      this._castling.b &= ~BITS.KSIDE_CASTLE;\n    }\n  }\n  _updateEnPassantSquare() {\n    if (this._epSquare === EMPTY) {\n      return;\n    }\n    const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n    const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n    const attackers = [currentSquare + 1, currentSquare - 1];\n    if (this._board[startSquare] !== null || this._board[this._epSquare] !== null || this._board[currentSquare]?.color !== swapColor(this._turn) || this._board[currentSquare]?.type !== PAWN) {\n      this._epSquare = EMPTY;\n      return;\n    }\n    const canCapture = square => !(square & 0x88) && this._board[square]?.color === this._turn && this._board[square]?.type === PAWN;\n    if (!attackers.some(canCapture)) {\n      this._epSquare = EMPTY;\n    }\n  }\n  _attacked(color, square) {\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      // if empty square or wrong color\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue;\n      }\n      const piece = this._board[i];\n      const difference = i - square;\n      // skip - to/from square are the same\n      if (difference === 0) {\n        continue;\n      }\n      const index = difference + 119;\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true;\n          } else {\n            if (piece.color === BLACK) return true;\n          }\n          continue;\n        }\n        // if the piece is a knight or a king\n        if (piece.type === 'n' || piece.type === 'k') return true;\n        const offset = RAYS[index];\n        let j = i + offset;\n        let blocked = false;\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true;\n            break;\n          }\n          j += offset;\n        }\n        if (!blocked) return true;\n      }\n    }\n    return false;\n  }\n  _isKingAttacked(color) {\n    const square = this._kings[color];\n    return square === -1 ? false : this._attacked(swapColor(color), square);\n  }\n  isAttacked(square, attackedBy) {\n    return this._attacked(attackedBy, Ox88[square]);\n  }\n  isCheck() {\n    return this._isKingAttacked(this._turn);\n  }\n  inCheck() {\n    return this.isCheck();\n  }\n  isCheckmate() {\n    return this.isCheck() && this._moves().length === 0;\n  }\n  isStalemate() {\n    return !this.isCheck() && this._moves().length === 0;\n  }\n  isInsufficientMaterial() {\n    /*\r\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\r\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\r\n     *\r\n     * k.b. vs k.n. with mate in 1:\r\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\r\n     */\n    const pieces = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0\n    };\n    const bishops = [];\n    let numPieces = 0;\n    let squareColor = 0;\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2;\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      const piece = this._board[i];\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n        if (piece.type === BISHOP) {\n          bishops.push(squareColor);\n        }\n        numPieces++;\n      }\n    }\n    // k vs. k\n    if (numPieces === 2) {\n      return true;\n    } else if (\n    // k vs. kn .... or .... k vs. kb\n    numPieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n      return true;\n    } else if (numPieces === pieces[BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0;\n      const len = bishops.length;\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i];\n      }\n      if (sum === 0 || sum === len) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isThreefoldRepetition() {\n    const moves = [];\n    const positions = {};\n    let repetition = false;\n    while (true) {\n      const move = this._undoMove();\n      if (!move) break;\n      moves.push(move);\n    }\n    while (true) {\n      /*\r\n       * remove the last two fields in the FEN string, they're not needed when\r\n       * checking for draw by rep\r\n       */\n      const fen = this.fen().split(' ').slice(0, 4).join(' ');\n      // has the position occurred three or move times\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n      if (positions[fen] >= 3) {\n        repetition = true;\n      }\n      const move = moves.pop();\n      if (!move) {\n        break;\n      } else {\n        this._makeMove(move);\n      }\n    }\n    return repetition;\n  }\n  isDraw() {\n    return this._halfMoves >= 100 ||\n    // 50 moves per side = 100 half moves\n    this.isStalemate() || this.isInsufficientMaterial() || this.isThreefoldRepetition();\n  }\n  isGameOver() {\n    return this.isCheckmate() || this.isStalemate() || this.isDraw();\n  }\n  moves({\n    verbose = false,\n    square = undefined,\n    piece = undefined\n  } = {}) {\n    const moves = this._moves({\n      square,\n      piece\n    });\n    if (verbose) {\n      return moves.map(move => this._makePretty(move));\n    } else {\n      return moves.map(move => this._moveToSan(move, moves));\n    }\n  }\n  _moves({\n    legal = true,\n    piece = undefined,\n    square = undefined\n  } = {}) {\n    const forSquare = square ? square.toLowerCase() : undefined;\n    const forPiece = piece?.toLowerCase();\n    const moves = [];\n    const us = this._turn;\n    const them = swapColor(us);\n    let firstSquare = Ox88.a8;\n    let lastSquare = Ox88.h1;\n    let singleSquare = false;\n    // are we generating moves for a single square?\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return [];\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare];\n        singleSquare = true;\n      }\n    }\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      // did we run off the end of the board\n      if (from & 0x88) {\n        from += 7;\n        continue;\n      }\n      // empty square or opponent, skip\n      if (!this._board[from] || this._board[from].color === them) {\n        continue;\n      }\n      const {\n        type\n      } = this._board[from];\n      let to;\n      if (type === PAWN) {\n        if (forPiece && forPiece !== type) continue;\n        // single square, non-capturing\n        to = from + PAWN_OFFSETS[us][0];\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, PAWN);\n          // double square\n          to = from + PAWN_OFFSETS[us][1];\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n          }\n        }\n        // pawn captures\n        for (let j = 2; j < 4; j++) {\n          to = from + PAWN_OFFSETS[us][j];\n          if (to & 0x88) continue;\n          if (this._board[to]?.color === them) {\n            addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue;\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j];\n          to = from;\n          while (true) {\n            to += offset;\n            if (to & 0x88) break;\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type);\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break;\n              addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n              break;\n            }\n            /* break, if knight or king */\n            if (type === KNIGHT || type === KING) break;\n          }\n        }\n      }\n    }\n    /*\r\n     * check for castling if we're:\r\n     *   a) generating all moves, or\r\n     *   b) doing single square move generation on the king's square\r\n     */\n    if (forPiece === undefined || forPiece === KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        // king-side castling\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us];\n          const castlingTo = castlingFrom + 2;\n          if (!this._board[castlingFrom + 1] && !this._board[castlingTo] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom + 1) && !this._attacked(them, castlingTo)) {\n            addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n          }\n        }\n        // queen-side castling\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us];\n          const castlingTo = castlingFrom - 2;\n          if (!this._board[castlingFrom - 1] && !this._board[castlingFrom - 2] && !this._board[castlingFrom - 3] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom - 1) && !this._attacked(them, castlingTo)) {\n            addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n          }\n        }\n      }\n    }\n    /*\r\n     * return all pseudo-legal moves (this includes moves that allow the king\r\n     * to be captured)\r\n     */\n    if (!legal || this._kings[us] === -1) {\n      return moves;\n    }\n    // filter out illegal moves\n    const legalMoves = [];\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i]);\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i]);\n      }\n      this._undoMove();\n    }\n    return legalMoves;\n  }\n  move(move, {\n    strict = false\n  } = {}) {\n    /*\r\n     * The move function can be called with in the following parameters:\r\n     *\r\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\r\n     *\r\n     * .move({ from: 'h7', <- argument is a move object\r\n     *         to :'h8',\r\n     *         promotion: 'q' })\r\n     *\r\n     *\r\n     * An optional strict argument may be supplied to tell chess.js to\r\n     * strictly follow the SAN specification.\r\n     */\n    let moveObj = null;\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, strict);\n    } else if (typeof move === 'object') {\n      const moves = this._moves();\n      // convert the pretty move object to an ugly move object\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n          moveObj = moves[i];\n          break;\n        }\n      }\n    }\n    // failed to find move\n    if (!moveObj) {\n      if (typeof move === 'string') {\n        throw new Error(`Invalid move: ${move}`);\n      } else {\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n      }\n    }\n    /*\r\n     * need to make a copy of move because we can't generate SAN after the move\r\n     * is made\r\n     */\n    const prettyMove = this._makePretty(moveObj);\n    this._makeMove(moveObj);\n    return prettyMove;\n  }\n  _push(move) {\n    this._history.push({\n      move,\n      kings: {\n        b: this._kings.b,\n        w: this._kings.w\n      },\n      turn: this._turn,\n      castling: {\n        b: this._castling.b,\n        w: this._castling.w\n      },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber\n    });\n  }\n  _makeMove(move) {\n    const us = this._turn;\n    const them = swapColor(us);\n    this._push(move);\n    this._board[move.to] = this._board[move.from];\n    delete this._board[move.from];\n    // if ep capture, remove the captured pawn\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === BLACK) {\n        delete this._board[move.to - 16];\n      } else {\n        delete this._board[move.to + 16];\n      }\n    }\n    // if pawn promotion, replace with new piece\n    if (move.promotion) {\n      this._board[move.to] = {\n        type: move.promotion,\n        color: us\n      };\n    }\n    // if we moved the king\n    if (this._board[move.to].type === KING) {\n      this._kings[us] = move.to;\n      // if we castled, move the rook next to the king\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1;\n        const castlingFrom = move.to + 1;\n        this._board[castlingTo] = this._board[castlingFrom];\n        delete this._board[castlingFrom];\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1;\n        const castlingFrom = move.to - 2;\n        this._board[castlingTo] = this._board[castlingFrom];\n        delete this._board[castlingFrom];\n      }\n      // turn off castling\n      this._castling[us] = 0;\n    }\n    // turn off castling if we move a rook\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (move.from === ROOKS[us][i].square && this._castling[us] & ROOKS[us][i].flag) {\n          this._castling[us] ^= ROOKS[us][i].flag;\n          break;\n        }\n      }\n    }\n    // turn off castling if we capture a rook\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (move.to === ROOKS[them][i].square && this._castling[them] & ROOKS[them][i].flag) {\n          this._castling[them] ^= ROOKS[them][i].flag;\n          break;\n        }\n      }\n    }\n    // if big pawn move, update the en passant square\n    if (move.flags & BITS.BIG_PAWN) {\n      if (us === BLACK) {\n        this._epSquare = move.to - 16;\n      } else {\n        this._epSquare = move.to + 16;\n      }\n    } else {\n      this._epSquare = EMPTY;\n    }\n    // reset the 50 move counter if a pawn is moved or a piece is captured\n    if (move.piece === PAWN) {\n      this._halfMoves = 0;\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0;\n    } else {\n      this._halfMoves++;\n    }\n    if (us === BLACK) {\n      this._moveNumber++;\n    }\n    this._turn = them;\n  }\n  undo() {\n    const move = this._undoMove();\n    return move ? this._makePretty(move) : null;\n  }\n  _undoMove() {\n    const old = this._history.pop();\n    if (old === undefined) {\n      return null;\n    }\n    const move = old.move;\n    this._kings = old.kings;\n    this._turn = old.turn;\n    this._castling = old.castling;\n    this._epSquare = old.epSquare;\n    this._halfMoves = old.halfMoves;\n    this._moveNumber = old.moveNumber;\n    const us = this._turn;\n    const them = swapColor(us);\n    this._board[move.from] = this._board[move.to];\n    this._board[move.from].type = move.piece; // to undo any promotions\n    delete this._board[move.to];\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index;\n        if (us === BLACK) {\n          index = move.to - 16;\n        } else {\n          index = move.to + 16;\n        }\n        this._board[index] = {\n          type: PAWN,\n          color: them\n        };\n      } else {\n        // regular capture\n        this._board[move.to] = {\n          type: move.captured,\n          color: them\n        };\n      }\n    }\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo, castlingFrom;\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1;\n        castlingFrom = move.to - 1;\n      } else {\n        castlingTo = move.to - 2;\n        castlingFrom = move.to + 1;\n      }\n      this._board[castlingTo] = this._board[castlingFrom];\n      delete this._board[castlingFrom];\n    }\n    return move;\n  }\n  pgn({\n    newline = '\\n',\n    maxWidth = 0\n  } = {}) {\n    /*\r\n     * using the specification from http://www.chessclub.com/help/PGN-spec\r\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\r\n     */\n    const result = [];\n    let headerExists = false;\n    /* add the PGN header information */\n    for (const i in this._header) {\n      /*\r\n       * TODO: order of enumerated properties in header object is not\r\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\r\n       */\n      result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n      headerExists = true;\n    }\n    if (headerExists && this._history.length) {\n      result.push(newline);\n    }\n    const appendComment = moveString => {\n      const comment = this._comments[this.fen()];\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : '';\n        moveString = `${moveString}${delimiter}{${comment}}`;\n      }\n      return moveString;\n    };\n    // pop all of history onto reversed_history\n    const reversedHistory = [];\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n    const moves = [];\n    let moveString = '';\n    // special case of a commented starting position with no moves\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''));\n    }\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString);\n      const move = reversedHistory.pop();\n      // make TypeScript stop complaining about move being undefined\n      if (!move) {\n        break;\n      }\n      // if the position started with black to move, start PGN with #. ...\n      if (!this._history.length && move.color === 'b') {\n        const prefix = `${this._moveNumber}. ...`;\n        // is there a comment preceding the first move?\n        moveString = moveString ? `${moveString} ${prefix}` : prefix;\n      } else if (move.color === 'w') {\n        // store the previous generated move_string if we have one\n        if (moveString.length) {\n          moves.push(moveString);\n        }\n        moveString = this._moveNumber + '.';\n      }\n      moveString = moveString + ' ' + this._moveToSan(move, this._moves({\n        legal: true\n      }));\n      this._makeMove(move);\n    }\n    // are there any other leftover moves?\n    if (moveString.length) {\n      moves.push(appendComment(moveString));\n    }\n    // is there a result?\n    if (typeof this._header.Result !== 'undefined') {\n      moves.push(this._header.Result);\n    }\n    /*\r\n     * history should be back to what it was before we started generating PGN,\r\n     * so join together moves\r\n     */\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ');\n    }\n    // TODO (jah): huh?\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop();\n        return true;\n      }\n      return false;\n    };\n    // NB: this does not preserve comment whitespace.\n    const wrapComment = function (width, move) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue;\n        }\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--;\n          }\n          result.push(newline);\n          width = 0;\n        }\n        result.push(token);\n        width += token.length;\n        result.push(' ');\n        width++;\n      }\n      if (strip()) {\n        width--;\n      }\n      return width;\n    };\n    // wrap the PGN output at max_width\n    let currentWidth = 0;\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i]);\n          continue;\n        }\n      }\n      // if the current move will push past max_width\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        // don't end the line with whitespace\n        if (result[result.length - 1] === ' ') {\n          result.pop();\n        }\n        result.push(newline);\n        currentWidth = 0;\n      } else if (i !== 0) {\n        result.push(' ');\n        currentWidth++;\n      }\n      result.push(moves[i]);\n      currentWidth += moves[i].length;\n    }\n    return result.join('');\n  }\n  header(...args) {\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1];\n      }\n    }\n    return this._header;\n  }\n  loadPgn(pgn, {\n    strict = false,\n    newlineChar = '\\r?\\n'\n  } = {}) {\n    function mask(str) {\n      return str.replace(/\\\\/g, '\\\\');\n    }\n    function parsePgnHeader(header) {\n      const headerObj = {};\n      const headers = header.split(new RegExp(mask(newlineChar)));\n      let key = '';\n      let value = '';\n      for (let i = 0; i < headers.length; i++) {\n        const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n        key = headers[i].replace(regex, '$1');\n        value = headers[i].replace(regex, '$2');\n        if (key.trim().length > 0) {\n          headerObj[key] = value;\n        }\n      }\n      return headerObj;\n    }\n    // strip whitespace from head/tail of PGN block\n    pgn = pgn.trim();\n    /*\r\n     * RegExp to split header. Takes advantage of the fact that header and movetext\r\n     * will always have a blank line between them (ie, two newline_char's). Handles\r\n     * case where movetext is empty by matching newlineChar until end of string is\r\n     * matched - effectively trimming from the end extra newlineChar.\r\n     *\r\n     * With default newline_char, will equal:\r\n     * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\r\n     */\n    const headerRegex = new RegExp('^(\\\\[((?:' + mask(newlineChar) + ')|.)*\\\\])' + '((?:\\\\s*' + mask(newlineChar) + '){2}|(?:\\\\s*' + mask(newlineChar) + ')*$)');\n    // If no header given, begin with moves.\n    const headerRegexResults = headerRegex.exec(pgn);\n    const headerString = headerRegexResults ? headerRegexResults.length >= 2 ? headerRegexResults[1] : '' : '';\n    // Put the board in the starting position\n    this.reset();\n    // parse PGN header\n    const headers = parsePgnHeader(headerString);\n    let fen = '';\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key];\n      }\n      this.header(key, headers[key]);\n    }\n    /*\r\n     * the permissive parser should attempt to load a fen tag, even if it's the\r\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\r\n     */\n    if (!strict) {\n      if (fen) {\n        this.load(fen, true);\n      }\n    } else {\n      /*\r\n       * strict parser - load the starting position indicated by [Setup '1']\r\n       * and [FEN position]\r\n       */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers)) {\n          throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n        }\n        // second argument to load: don't clear the headers\n        this.load(headers['FEN'], true);\n      }\n    }\n    /*\r\n     * NB: the regexes below that delete move numbers, recursive annotations,\r\n     * and numeric annotation glyphs may also match text in comments. To\r\n     * prevent this, we transform comments by hex-encoding them in place and\r\n     * decoding them again after the other tokens have been deleted.\r\n     *\r\n     * While the spec states that PGN files should be ASCII encoded, we use\r\n     * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\r\n     * for modern users\r\n     */\n    function toHex(s) {\n      return Array.from(s).map(function (c) {\n        /*\r\n         * encodeURI doesn't transform most ASCII characters, so we handle\r\n         * these ourselves\r\n         */\n        return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n      }).join('');\n    }\n    function fromHex(s) {\n      return s.length == 0 ? '' : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n    }\n    const encodeComment = function (s) {\n      s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n      return `{${toHex(s.slice(1, s.length - 1))}}`;\n    };\n    const decodeComment = function (s) {\n      if (s.startsWith('{') && s.endsWith('}')) {\n        return fromHex(s.slice(1, s.length - 1));\n      }\n    };\n    // delete header to get the moves\n    let ms = pgn.replace(headerString, '').replace(\n    // encode comments so they don't get deleted below\n    new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n      return bracket !== undefined ? encodeComment(bracket) : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n    }).replace(new RegExp(mask(newlineChar), 'g'), ' ');\n    // delete recursive annotation variations\n    const ravRegex = /(\\([^()]+\\))+?/g;\n    while (ravRegex.test(ms)) {\n      ms = ms.replace(ravRegex, '');\n    }\n    // delete move numbers\n    ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n    // delete ... indicating black to move\n    ms = ms.replace(/\\.\\.\\./g, '');\n    /* delete numeric annotation glyphs */\n    ms = ms.replace(/\\$\\d+/g, '');\n    // trim and get array of moves\n    let moves = ms.trim().split(new RegExp(/\\s+/));\n    // delete empty entries\n    moves = moves.filter(move => move !== '');\n    let result = '';\n    for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n      const comment = decodeComment(moves[halfMove]);\n      if (comment !== undefined) {\n        this._comments[this.fen()] = comment;\n        continue;\n      }\n      const move = this._moveFromSan(moves[halfMove], strict);\n      // invalid move\n      if (move == null) {\n        // was the move an end of game marker\n        if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n          result = moves[halfMove];\n        } else {\n          throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n        }\n      } else {\n        // reset the end of game marker if making a valid move\n        result = '';\n        this._makeMove(move);\n      }\n    }\n    /*\r\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\r\n     * the termination marker. Only do this when headers are present, but the\r\n     * result tag is missing\r\n     */\n    if (result && Object.keys(this._header).length && !this._header['Result']) {\n      this.header('Result', result);\n    }\n  }\n  /*\r\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\r\n   * (SAN)\r\n   *\r\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\r\n   * on overly disambiguated moves (see below):\r\n   *\r\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\r\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\r\n   * 4. ... Ne7 is technically the valid SAN\r\n   */\n  _moveToSan(move, moves) {\n    let output = '';\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O';\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O';\n    } else {\n      if (move.piece !== PAWN) {\n        const disambiguator = getDisambiguator(move, moves);\n        output += move.piece.toUpperCase() + disambiguator;\n      }\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0];\n        }\n        output += 'x';\n      }\n      output += algebraic(move.to);\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase();\n      }\n    }\n    this._makeMove(move);\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#';\n      } else {\n        output += '+';\n      }\n    }\n    this._undoMove();\n    return output;\n  }\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  _moveFromSan(move, strict = false) {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    const cleanMove = strippedSan(move);\n    let pieceType = inferPieceType(cleanMove);\n    let moves = this._moves({\n      legal: true,\n      piece: pieceType\n    });\n    // strict parser\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i];\n      }\n    }\n    // the strict parser failed\n    if (strict) {\n      return null;\n    }\n    let piece = undefined;\n    let matches = undefined;\n    let from = undefined;\n    let to = undefined;\n    let promotion = undefined;\n    /*\r\n     * The default permissive (non-strict) parser allows the user to parse\r\n     * non-standard chess notations. This parser is only run after the strict\r\n     * Standard Algebraic Notation (SAN) parser has failed.\r\n     *\r\n     * When running the permissive parser, we'll run a regex to grab the piece, the\r\n     * to/from square, and an optional promotion piece. This regex will\r\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\r\n     * f7f8q, b1c3\r\n     *\r\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\r\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\r\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\r\n     * move). In these cases, the permissive parser will default to the most\r\n     * basic interpretation (which is b1c3 parsing to Nc3).\r\n     */\n    let overlyDisambiguated = false;\n    matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n    //     piece         from              to       promotion\n    );\n\n    if (matches) {\n      piece = matches[1];\n      from = matches[2];\n      to = matches[3];\n      promotion = matches[4];\n      if (from.length == 1) {\n        overlyDisambiguated = true;\n      }\n    } else {\n      /*\r\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\r\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\r\n       * there is one legal knight move to e7). In this case, the value of\r\n       * 'from' variable will be a rank or file, not a square.\r\n       */\n      matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n      if (matches) {\n        piece = matches[1];\n        from = matches[2];\n        to = matches[3];\n        promotion = matches[4];\n        if (from.length == 1) {\n          overlyDisambiguated = true;\n        }\n      }\n    }\n    pieceType = inferPieceType(cleanMove);\n    moves = this._moves({\n      legal: true,\n      piece: piece ? piece : pieceType\n    });\n    if (!to) {\n      return null;\n    }\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (!from) {\n        // if there is no from square, it could be just 'x' missing from a capture\n        if (cleanMove === strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n          return moves[i];\n        }\n        // hand-compare move properties with the results from our permissive regex\n      } else if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[from] == moves[i].from && Ox88[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n        return moves[i];\n      } else if (overlyDisambiguated) {\n        /*\r\n         * SPECIAL CASE: we parsed a move string that may have an unneeded\r\n         * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\r\n         */\n        const square = algebraic(moves[i].from);\n        if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[to] == moves[i].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n          return moves[i];\n        }\n      }\n    }\n    return null;\n  }\n  ascii() {\n    let s = '   +------------------------+\\n';\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // display the rank\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |';\n      }\n      if (this._board[i]) {\n        const piece = this._board[i].type;\n        const color = this._board[i].color;\n        const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n        s += ' ' + symbol + ' ';\n      } else {\n        s += ' . ';\n      }\n      if (i + 1 & 0x88) {\n        s += '|\\n';\n        i += 8;\n      }\n    }\n    s += '   +------------------------+\\n';\n    s += '     a  b  c  d  e  f  g  h';\n    return s;\n  }\n  perft(depth) {\n    const moves = this._moves({\n      legal: false\n    });\n    let nodes = 0;\n    const color = this._turn;\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i]);\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1);\n        } else {\n          nodes++;\n        }\n      }\n      this._undoMove();\n    }\n    return nodes;\n  }\n  // pretty = external move object\n  _makePretty(uglyMove) {\n    const {\n      color,\n      piece,\n      from,\n      to,\n      flags,\n      captured,\n      promotion\n    } = uglyMove;\n    let prettyFlags = '';\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        prettyFlags += FLAGS[flag];\n      }\n    }\n    const fromAlgebraic = algebraic(from);\n    const toAlgebraic = algebraic(to);\n    const move = {\n      color,\n      piece,\n      from: fromAlgebraic,\n      to: toAlgebraic,\n      san: this._moveToSan(uglyMove, this._moves({\n        legal: true\n      })),\n      flags: prettyFlags,\n      lan: fromAlgebraic + toAlgebraic,\n      before: this.fen(),\n      after: ''\n    };\n    // generate the FEN for the 'after' key\n    this._makeMove(uglyMove);\n    move.after = this.fen();\n    this._undoMove();\n    if (captured) {\n      move.captured = captured;\n    }\n    if (promotion) {\n      move.promotion = promotion;\n      move.lan += promotion;\n    }\n    return move;\n  }\n  turn() {\n    return this._turn;\n  }\n  board() {\n    const output = [];\n    let row = [];\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null);\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color\n        });\n      }\n      if (i + 1 & 0x88) {\n        output.push(row);\n        row = [];\n        i += 8;\n      }\n    }\n    return output;\n  }\n  squareColor(square) {\n    if (square in Ox88) {\n      const sq = Ox88[square];\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n    }\n    return null;\n  }\n  history({\n    verbose = false\n  } = {}) {\n    const reversedHistory = [];\n    const moveHistory = [];\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n    while (true) {\n      const move = reversedHistory.pop();\n      if (!move) {\n        break;\n      }\n      if (verbose) {\n        moveHistory.push(this._makePretty(move));\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()));\n      }\n      this._makeMove(move);\n    }\n    return moveHistory;\n  }\n  _pruneComments() {\n    const reversedHistory = [];\n    const currentComments = {};\n    const copyComment = fen => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen];\n      }\n    };\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n    copyComment(this.fen());\n    while (true) {\n      const move = reversedHistory.pop();\n      if (!move) {\n        break;\n      }\n      this._makeMove(move);\n      copyComment(this.fen());\n    }\n    this._comments = currentComments;\n  }\n  getComment() {\n    return this._comments[this.fen()];\n  }\n  setComment(comment) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n  }\n  deleteComment() {\n    const comment = this._comments[this.fen()];\n    delete this._comments[this.fen()];\n    return comment;\n  }\n  getComments() {\n    this._pruneComments();\n    return Object.keys(this._comments).map(fen => {\n      return {\n        fen: fen,\n        comment: this._comments[fen]\n      };\n    });\n  }\n  deleteComments() {\n    this._pruneComments();\n    return Object.keys(this._comments).map(fen => {\n      const comment = this._comments[fen];\n      delete this._comments[fen];\n      return {\n        fen: fen,\n        comment: comment\n      };\n    });\n  }\n  setCastlingRights(color, rights) {\n    for (const side of [KING, QUEEN]) {\n      if (rights[side] !== undefined) {\n        if (rights[side]) {\n          this._castling[color] |= SIDES[side];\n        } else {\n          this._castling[color] &= ~SIDES[side];\n        }\n      }\n    }\n    this._updateCastlingRights();\n    const result = this.getCastlingRights(color);\n    return (rights[KING] === undefined || rights[KING] === result[KING]) && (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]);\n  }\n  getCastlingRights(color) {\n    return {\n      [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n      [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0\n    };\n  }\n  moveNumber() {\n    return this._moveNumber;\n  }\n}","map":{"version":3,"names":["WHITE","BLACK","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","DEFAULT_POSITION","EMPTY","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","SQUARES","BITS","Ox88","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","PIECE_MASKS","p","SYMBOLS","PROMOTIONS","RANK_1","RANK_2","RANK_7","RANK_8","SIDES","ROOKS","square","flag","SECOND_RANK","TERMINATION_MARKERS","rank","file","isDigit","c","indexOf","algebraic","f","substring","swapColor","color","validateFen","fen","tokens","split","length","ok","error","moveNumber","parseInt","isNaN","halfMoves","test","rows","i","sumFields","previousWasNumber","kings","regex","match","getDisambiguator","move","moves","from","to","piece","ambiguities","sameRank","sameFile","len","ambigFrom","ambigTo","ambigPiece","charAt","addMove","captured","undefined","flags","promotion","push","inferPieceType","san","pieceType","matches","toLowerCase","strippedSan","replace","Chess","_board","Array","_turn","_header","_kings","_epSquare","_halfMoves","_moveNumber","_history","_comments","_castling","constructor","load","clear","keepHeaders","_updateSetup","removeHeader","key","adjustments","concat","slice","join","Error","position","put","type","empty","toUpperCase","castling","epSquare","bigPawnSquare","squares","_makeMove","isLegal","_isKingAttacked","_undoMove","reset","get","sq","_updateCastlingRights","_updateEnPassantSquare","remove","whiteKingInPlace","blackKingInPlace","startSquare","currentSquare","attackers","canCapture","some","_attacked","difference","index","offset","j","blocked","isAttacked","attackedBy","isCheck","inCheck","isCheckmate","_moves","isStalemate","isInsufficientMaterial","pieces","bishops","numPieces","squareColor","sum","isThreefoldRepetition","positions","repetition","pop","isDraw","isGameOver","verbose","map","_makePretty","_moveToSan","legal","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","castlingFrom","castlingTo","legalMoves","strict","moveObj","_moveFromSan","JSON","stringify","prettyMove","_push","turn","undo","old","pgn","newline","maxWidth","result","headerExists","appendComment","moveString","comment","delimiter","reversedHistory","prefix","Result","strip","wrapComment","width","token","currentWidth","includes","header","args","loadPgn","newlineChar","mask","str","parsePgnHeader","headerObj","headers","RegExp","value","trim","headerRegex","headerRegexResults","exec","headerString","toHex","s","charCodeAt","toString","encodeURIComponent","fromHex","decodeURIComponent","encodeComment","decodeComment","startsWith","endsWith","ms","_match","bracket","semicolon","ravRegex","filter","halfMove","Object","keys","output","disambiguator","cleanMove","overlyDisambiguated","ascii","symbol","perft","depth","nodes","uglyMove","prettyFlags","fromAlgebraic","toAlgebraic","lan","before","after","board","row","history","moveHistory","_pruneComments","currentComments","copyComment","getComment","setComment","deleteComment","getComments","deleteComments","setCastlingRights","rights","side","getCastlingRights"],"sources":["C:\\Users\\RetailAdmin\\Desktop\\Frontend\\node_modules\\chess.js\\src\\chess.ts"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nexport const WHITE = 'w'\r\nexport const BLACK = 'b'\r\n\r\nexport const PAWN = 'p'\r\nexport const KNIGHT = 'n'\r\nexport const BISHOP = 'b'\r\nexport const ROOK = 'r'\r\nexport const QUEEN = 'q'\r\nexport const KING = 'k'\r\n\r\nexport type Color = 'w' | 'b'\r\nexport type PieceSymbol = 'p' | 'n' | 'b' | 'r' | 'q' | 'k'\r\n\r\n// prettier-ignore\r\nexport type Square =\r\n    'a8' | 'b8' | 'c8' | 'd8' | 'e8' | 'f8' | 'g8' | 'h8' |\r\n    'a7' | 'b7' | 'c7' | 'd7' | 'e7' | 'f7' | 'g7' | 'h7' |\r\n    'a6' | 'b6' | 'c6' | 'd6' | 'e6' | 'f6' | 'g6' | 'h6' |\r\n    'a5' | 'b5' | 'c5' | 'd5' | 'e5' | 'f5' | 'g5' | 'h5' |\r\n    'a4' | 'b4' | 'c4' | 'd4' | 'e4' | 'f4' | 'g4' | 'h4' |\r\n    'a3' | 'b3' | 'c3' | 'd3' | 'e3' | 'f3' | 'g3' | 'h3' |\r\n    'a2' | 'b2' | 'c2' | 'd2' | 'e2' | 'f2' | 'g2' | 'h2' |\r\n    'a1' | 'b1' | 'c1' | 'd1' | 'e1' | 'f1' | 'g1' | 'h1'\r\n\r\nexport const DEFAULT_POSITION =\r\n  'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\r\n\r\nexport type Piece = {\r\n  color: Color\r\n  type: PieceSymbol\r\n}\r\n\r\ntype InternalMove = {\r\n  color: Color\r\n  from: number\r\n  to: number\r\n  piece: PieceSymbol\r\n  captured?: PieceSymbol\r\n  promotion?: PieceSymbol\r\n  flags: number\r\n}\r\n\r\ninterface History {\r\n  move: InternalMove\r\n  kings: Record<Color, number>\r\n  turn: Color\r\n  castling: Record<Color, number>\r\n  epSquare: number\r\n  halfMoves: number\r\n  moveNumber: number\r\n}\r\n\r\nexport type Move = {\r\n  color: Color\r\n  from: Square\r\n  to: Square\r\n  piece: PieceSymbol\r\n  captured?: PieceSymbol\r\n  promotion?: PieceSymbol\r\n  flags: string\r\n  san: string\r\n  lan: string\r\n  before: string\r\n  after: string\r\n}\r\n\r\nconst EMPTY = -1\r\n\r\nconst FLAGS: Record<string, string> = {\r\n  NORMAL: 'n',\r\n  CAPTURE: 'c',\r\n  BIG_PAWN: 'b',\r\n  EP_CAPTURE: 'e',\r\n  PROMOTION: 'p',\r\n  KSIDE_CASTLE: 'k',\r\n  QSIDE_CASTLE: 'q',\r\n}\r\n\r\n// prettier-ignore\r\nexport const SQUARES: Square[] = [\r\n  'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\r\n  'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\r\n  'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\r\n  'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\r\n  'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\r\n  'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\r\n  'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\r\n  'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\r\n]\r\n\r\nconst BITS: Record<string, number> = {\r\n  NORMAL: 1,\r\n  CAPTURE: 2,\r\n  BIG_PAWN: 4,\r\n  EP_CAPTURE: 8,\r\n  PROMOTION: 16,\r\n  KSIDE_CASTLE: 32,\r\n  QSIDE_CASTLE: 64,\r\n}\r\n\r\n/*\r\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\r\n * ----------------------------------------------------------------------------\r\n * From https://github.com/jhlywa/chess.js/issues/230\r\n *\r\n * A lot of people are confused when they first see the internal representation\r\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\r\n * stores the board as an 8x16 array. This is purely for efficiency but has a\r\n * couple of interesting benefits:\r\n *\r\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\r\n *    square with 0x88, if the result is non-zero then the square is off the\r\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\r\n *    there are 8 possible directions in which the knight can move. These\r\n *    directions are relative to the 8x16 board and are stored in the\r\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\r\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\r\n *    (because of two-complement representation of -18). The non-zero result\r\n *    means the square is off the board and the move is illegal. Take the\r\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\r\n *    means the square is on the board.\r\n *\r\n * 2. The relative distance (or difference) between two squares on a 8x16 board\r\n *    is unique and can be used to inexpensively determine if a piece on a\r\n *    square can attack any other arbitrary square. For example, let's see if a\r\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\r\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\r\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\r\n *    bitmask of pieces that can attack from that distance and direction.\r\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\r\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\r\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\r\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\r\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\r\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\r\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\r\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\r\n */\r\n\r\n// prettier-ignore\r\n// eslint-disable-next-line\r\nconst Ox88: Record<Square, number> = {\r\n  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\r\n  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\r\n  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\r\n  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\r\n  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\r\n  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\r\n  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\r\n  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\r\n}\r\n\r\nconst PAWN_OFFSETS = {\r\n  b: [16, 32, 17, 15],\r\n  w: [-16, -32, -17, -15],\r\n}\r\n\r\nconst PIECE_OFFSETS = {\r\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\r\n  b: [-17, -15, 17, 15],\r\n  r: [-16, 1, 16, -1],\r\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\r\n  k: [-17, -16, -15, 1, 17, 16, 15, -1],\r\n}\r\n\r\n// prettier-ignore\r\nconst ATTACKS = [\r\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\r\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\r\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\r\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\r\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\r\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\r\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n  24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\r\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\r\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\r\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\r\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\r\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\r\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\r\n];\r\n\r\n// prettier-ignore\r\nconst RAYS = [\r\n   17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\r\n    0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\r\n    0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\r\n    0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\r\n    0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\r\n    0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\r\n    0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\r\n    1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\r\n    0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\r\n    0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\r\n    0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\r\n    0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\r\n    0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\r\n    0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\r\n  -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\r\n];\r\n\r\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 }\r\n\r\nconst SYMBOLS = 'pnbrqkPNBRQK'\r\n\r\nconst PROMOTIONS: PieceSymbol[] = [KNIGHT, BISHOP, ROOK, QUEEN]\r\n\r\nconst RANK_1 = 7\r\nconst RANK_2 = 6\r\n/*\r\n * const RANK_3 = 5\r\n * const RANK_4 = 4\r\n * const RANK_5 = 3\r\n * const RANK_6 = 2\r\n */\r\nconst RANK_7 = 1\r\nconst RANK_8 = 0\r\n\r\nconst SIDES = {\r\n  [KING]: BITS.KSIDE_CASTLE,\r\n  [QUEEN]: BITS.QSIDE_CASTLE\r\n}\r\n\r\nconst ROOKS = {\r\n  w: [\r\n    { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\r\n    { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\r\n  ],\r\n  b: [\r\n    { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\r\n    { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\r\n  ],\r\n}\r\n\r\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 }\r\n\r\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*']\r\n\r\n// Extracts the zero-based rank of an 0x88 square.\r\nfunction rank(square: number): number {\r\n  return square >> 4\r\n}\r\n\r\n// Extracts the zero-based file of an 0x88 square.\r\nfunction file(square: number): number {\r\n  return square & 0xf\r\n}\r\n\r\nfunction isDigit(c: string): boolean {\r\n  return '0123456789'.indexOf(c) !== -1\r\n}\r\n\r\n// Converts a 0x88 square to algebraic notation.\r\nfunction algebraic(square: number): Square {\r\n  const f = file(square)\r\n  const r = rank(square)\r\n  return ('abcdefgh'.substring(f, f + 1) +\r\n    '87654321'.substring(r, r + 1)) as Square\r\n}\r\n\r\nfunction swapColor(color: Color): Color {\r\n  return color === WHITE ? BLACK : WHITE\r\n}\r\n\r\nexport function validateFen(fen: string) {\r\n  // 1st criterion: 6 space-seperated fields?\r\n  const tokens = fen.split(/\\s+/)\r\n  if (tokens.length !== 6) {\r\n    return {\r\n      ok: false,\r\n      error: 'Invalid FEN: must contain six space-delimited fields',\r\n    }\r\n  }\r\n\r\n  // 2nd criterion: move number field is a integer value > 0?\r\n  const moveNumber = parseInt(tokens[5], 10)\r\n  if (isNaN(moveNumber) || moveNumber <= 0) {\r\n    return {\r\n      ok: false,\r\n      error: 'Invalid FEN: move number must be a positive integer',\r\n    }\r\n  }\r\n\r\n  // 3rd criterion: half move counter is an integer >= 0?\r\n  const halfMoves = parseInt(tokens[4], 10)\r\n  if (isNaN(halfMoves) || halfMoves < 0) {\r\n    return {\r\n      ok: false,\r\n      error:\r\n        'Invalid FEN: half move counter number must be a non-negative integer',\r\n    }\r\n  }\r\n\r\n  // 4th criterion: 4th field is a valid e.p.-string?\r\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\r\n    return { ok: false, error: 'Invalid FEN: en-passant square is invalid' }\r\n  }\r\n\r\n  // 5th criterion: 3th field is a valid castle-string?\r\n  if (/[^kKqQ-]/.test(tokens[2])) {\r\n    return { ok: false, error: 'Invalid FEN: castling availability is invalid' }\r\n  }\r\n\r\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\r\n  if (!/^(w|b)$/.test(tokens[1])) {\r\n    return { ok: false, error: 'Invalid FEN: side-to-move is invalid' }\r\n  }\r\n\r\n  // 7th criterion: 1st field contains 8 rows?\r\n  const rows = tokens[0].split('/')\r\n  if (rows.length !== 8) {\r\n    return {\r\n      ok: false,\r\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\r\n    }\r\n  }\r\n\r\n  // 8th criterion: every row is valid?\r\n  for (let i = 0; i < rows.length; i++) {\r\n    // check for right sum of fields AND not two numbers in succession\r\n    let sumFields = 0\r\n    let previousWasNumber = false\r\n\r\n    for (let k = 0; k < rows[i].length; k++) {\r\n      if (isDigit(rows[i][k])) {\r\n        if (previousWasNumber) {\r\n          return {\r\n            ok: false,\r\n            error: 'Invalid FEN: piece data is invalid (consecutive number)',\r\n          }\r\n        }\r\n        sumFields += parseInt(rows[i][k], 10)\r\n        previousWasNumber = true\r\n      } else {\r\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\r\n          return {\r\n            ok: false,\r\n            error: 'Invalid FEN: piece data is invalid (invalid piece)',\r\n          }\r\n        }\r\n        sumFields += 1\r\n        previousWasNumber = false\r\n      }\r\n    }\r\n    if (sumFields !== 8) {\r\n      return {\r\n        ok: false,\r\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\r\n      }\r\n    }\r\n  }\r\n\r\n  if (\r\n    (tokens[3][1] == '3' && tokens[1] == 'w') ||\r\n    (tokens[3][1] == '6' && tokens[1] == 'b')\r\n  ) {\r\n    return { ok: false, error: 'Invalid FEN: illegal en-passant square' }\r\n  }\r\n\r\n  const kings = [\r\n    { color: 'white', regex: /K/g },\r\n    { color: 'black', regex: /k/g },\r\n  ]\r\n\r\n  for (const { color, regex } of kings) {\r\n    if (!regex.test(tokens[0])) {\r\n      return { ok: false, error: `Invalid FEN: missing ${color} king` }\r\n    }\r\n\r\n    if ((tokens[0].match(regex) || []).length > 1) {\r\n      return { ok: false, error: `Invalid FEN: too many ${color} kings` }\r\n    }\r\n  }\r\n\r\n  return { ok: true }\r\n}\r\n\r\n// this function is used to uniquely identify ambiguous moves\r\nfunction getDisambiguator(move: InternalMove, moves: InternalMove[]) {\r\n  const from = move.from\r\n  const to = move.to\r\n  const piece = move.piece\r\n\r\n  let ambiguities = 0\r\n  let sameRank = 0\r\n  let sameFile = 0\r\n\r\n  for (let i = 0, len = moves.length; i < len; i++) {\r\n    const ambigFrom = moves[i].from\r\n    const ambigTo = moves[i].to\r\n    const ambigPiece = moves[i].piece\r\n\r\n    /*\r\n     * if a move of the same piece type ends on the same to square, we'll need\r\n     * to add a disambiguator to the algebraic notation\r\n     */\r\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\r\n      ambiguities++\r\n\r\n      if (rank(from) === rank(ambigFrom)) {\r\n        sameRank++\r\n      }\r\n\r\n      if (file(from) === file(ambigFrom)) {\r\n        sameFile++\r\n      }\r\n    }\r\n  }\r\n\r\n  if (ambiguities > 0) {\r\n    if (sameRank > 0 && sameFile > 0) {\r\n      /*\r\n       * if there exists a similar moving piece on the same rank and file as\r\n       * the move in question, use the square as the disambiguator\r\n       */\r\n      return algebraic(from)\r\n    } else if (sameFile > 0) {\r\n      /*\r\n       * if the moving piece rests on the same file, use the rank symbol as the\r\n       * disambiguator\r\n       */\r\n      return algebraic(from).charAt(1)\r\n    } else {\r\n      // else use the file symbol\r\n      return algebraic(from).charAt(0)\r\n    }\r\n  }\r\n\r\n  return ''\r\n}\r\n\r\nfunction addMove(\r\n  moves: InternalMove[],\r\n  color: Color,\r\n  from: number,\r\n  to: number,\r\n  piece: PieceSymbol,\r\n  captured: PieceSymbol | undefined = undefined,\r\n  flags: number = BITS.NORMAL\r\n) {\r\n  const r = rank(to)\r\n\r\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\r\n    for (let i = 0; i < PROMOTIONS.length; i++) {\r\n      const promotion = PROMOTIONS[i]\r\n      moves.push({\r\n        color,\r\n        from,\r\n        to,\r\n        piece,\r\n        captured,\r\n        promotion,\r\n        flags: flags | BITS.PROMOTION,\r\n      })\r\n    }\r\n  } else {\r\n    moves.push({\r\n      color,\r\n      from,\r\n      to,\r\n      piece,\r\n      captured,\r\n      flags,\r\n    })\r\n  }\r\n}\r\n\r\nfunction inferPieceType(san: string) {\r\n  let pieceType = san.charAt(0)\r\n  if (pieceType >= 'a' && pieceType <= 'h') {\r\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/)\r\n    if (matches) {\r\n      return undefined\r\n    }\r\n    return PAWN\r\n  }\r\n  pieceType = pieceType.toLowerCase()\r\n  if (pieceType === 'o') {\r\n    return KING\r\n  }\r\n  return pieceType as PieceSymbol\r\n}\r\n\r\n// parses all of the decorators out of a SAN string\r\nfunction strippedSan(move: string) {\r\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\r\n}\r\n\r\nexport class Chess {\r\n  private _board = new Array<Piece>(128)\r\n  private _turn: Color = WHITE\r\n  private _header: Record<string, string> = {}\r\n  private _kings: Record<Color, number> = { w: EMPTY, b: EMPTY }\r\n  private _epSquare = -1\r\n  private _halfMoves = 0\r\n  private _moveNumber = 0\r\n  private _history: History[] = []\r\n  private _comments: Record<string, string> = {}\r\n  private _castling: Record<Color, number> = { w: 0, b: 0 }\r\n\r\n  constructor(fen = DEFAULT_POSITION) {\r\n    this.load(fen)\r\n  }\r\n\r\n  clear(keepHeaders = false) {\r\n    this._board = new Array<Piece>(128)\r\n    this._kings = { w: EMPTY, b: EMPTY }\r\n    this._turn = WHITE\r\n    this._castling = { w: 0, b: 0 }\r\n    this._epSquare = EMPTY\r\n    this._halfMoves = 0\r\n    this._moveNumber = 1\r\n    this._history = []\r\n    this._comments = {}\r\n    this._header = keepHeaders ? this._header : {}\r\n    this._updateSetup(this.fen())\r\n  }\r\n\r\n  removeHeader(key: string) {\r\n    if (key in this._header) {\r\n      delete this._header[key]\r\n    }\r\n  }\r\n\r\n  load(fen: string, keepHeaders = false) {\r\n    let tokens = fen.split(/\\s+/)\r\n\r\n    // append commonly omitted fen tokens\r\n    if (tokens.length >= 2 && tokens.length < 6) {\r\n      const adjustments = ['-', '-', '0', '1']\r\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ')\r\n    }\r\n\r\n    tokens = fen.split(/\\s+/)\r\n\r\n    const { ok, error } = validateFen(fen)\r\n    if (!ok) {\r\n      throw new Error(error)\r\n    }\r\n\r\n    const position = tokens[0]\r\n    let square = 0\r\n\r\n    this.clear(keepHeaders)\r\n\r\n    for (let i = 0; i < position.length; i++) {\r\n      const piece = position.charAt(i)\r\n\r\n      if (piece === '/') {\r\n        square += 8\r\n      } else if (isDigit(piece)) {\r\n        square += parseInt(piece, 10)\r\n      } else {\r\n        const color = piece < 'a' ? WHITE : BLACK\r\n        this.put(\r\n          { type: piece.toLowerCase() as PieceSymbol, color },\r\n          algebraic(square)\r\n        )\r\n        square++\r\n      }\r\n    }\r\n\r\n    this._turn = tokens[1] as Color\r\n\r\n    if (tokens[2].indexOf('K') > -1) {\r\n      this._castling.w |= BITS.KSIDE_CASTLE\r\n    }\r\n    if (tokens[2].indexOf('Q') > -1) {\r\n      this._castling.w |= BITS.QSIDE_CASTLE\r\n    }\r\n    if (tokens[2].indexOf('k') > -1) {\r\n      this._castling.b |= BITS.KSIDE_CASTLE\r\n    }\r\n    if (tokens[2].indexOf('q') > -1) {\r\n      this._castling.b |= BITS.QSIDE_CASTLE\r\n    }\r\n\r\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3] as Square]\r\n    this._halfMoves = parseInt(tokens[4], 10)\r\n    this._moveNumber = parseInt(tokens[5], 10)\r\n\r\n    this._updateSetup(this.fen())\r\n  }\r\n\r\n  fen() {\r\n    let empty = 0\r\n    let fen = ''\r\n\r\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n      if (this._board[i]) {\r\n        if (empty > 0) {\r\n          fen += empty\r\n          empty = 0\r\n        }\r\n        const { color, type: piece } = this._board[i]\r\n\r\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\r\n      } else {\r\n        empty++\r\n      }\r\n\r\n      if ((i + 1) & 0x88) {\r\n        if (empty > 0) {\r\n          fen += empty\r\n        }\r\n\r\n        if (i !== Ox88.h1) {\r\n          fen += '/'\r\n        }\r\n\r\n        empty = 0\r\n        i += 8\r\n      }\r\n    }\r\n\r\n    let castling = ''\r\n    if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\r\n      castling += 'K'\r\n    }\r\n    if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\r\n      castling += 'Q'\r\n    }\r\n    if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\r\n      castling += 'k'\r\n    }\r\n    if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\r\n      castling += 'q'\r\n    }\r\n\r\n    // do we have an empty castling flag?\r\n    castling = castling || '-'\r\n\r\n    let epSquare = '-'\r\n    /*\r\n     * only print the ep square if en passant is a valid move (pawn is present\r\n     * and ep capture is not pinned)\r\n     */\r\n    if (this._epSquare !== EMPTY) {\r\n      const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\r\n      const squares = [bigPawnSquare + 1, bigPawnSquare - 1]\r\n\r\n      for (const square of squares) {\r\n        // is the square off the board?\r\n        if (square & 0x88) {\r\n          continue\r\n        }\r\n\r\n        const color = this._turn\r\n\r\n        // is there a pawn that can capture the epSquare?\r\n        if (\r\n          this._board[square]?.color === color &&\r\n          this._board[square]?.type === PAWN\r\n        ) {\r\n          // if the pawn makes an ep capture, does it leave it's king in check?\r\n          this._makeMove({\r\n            color,\r\n            from: square,\r\n            to: this._epSquare,\r\n            piece: PAWN,\r\n            captured: PAWN,\r\n            flags: BITS.EP_CAPTURE,\r\n          })\r\n          const isLegal = !this._isKingAttacked(color)\r\n          this._undoMove()\r\n\r\n          // if ep is legal, break and set the ep square in the FEN output\r\n          if (isLegal) {\r\n            epSquare = algebraic(this._epSquare)\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return [\r\n      fen,\r\n      this._turn,\r\n      castling,\r\n      epSquare,\r\n      this._halfMoves,\r\n      this._moveNumber,\r\n    ].join(' ')\r\n  }\r\n\r\n  /*\r\n   * Called when the initial board setup is changed with put() or remove().\r\n   * modifies the SetUp and FEN properties of the header object. If the FEN\r\n   * is equal to the default position, the SetUp and FEN are deleted the setup\r\n   * is only updated if history.length is zero, ie moves haven't been made.\r\n   */\r\n  private _updateSetup(fen: string) {\r\n    if (this._history.length > 0) return\r\n\r\n    if (fen !== DEFAULT_POSITION) {\r\n      this._header['SetUp'] = '1'\r\n      this._header['FEN'] = fen\r\n    } else {\r\n      delete this._header['SetUp']\r\n      delete this._header['FEN']\r\n    }\r\n  }\r\n\r\n  reset() {\r\n    this.load(DEFAULT_POSITION)\r\n  }\r\n\r\n  get(square: Square) {\r\n    return this._board[Ox88[square]] || false\r\n  }\r\n\r\n  put({ type, color }: { type: PieceSymbol; color: Color }, square: Square) {\r\n    // check for piece\r\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\r\n      return false\r\n    }\r\n\r\n    // check for valid square\r\n    if (!(square in Ox88)) {\r\n      return false\r\n    }\r\n\r\n    const sq = Ox88[square]\r\n\r\n    // don't let the user place more than one king\r\n    if (\r\n      type == KING &&\r\n      !(this._kings[color] == EMPTY || this._kings[color] == sq)\r\n    ) {\r\n      return false\r\n    }\r\n\r\n    this._board[sq] = { type: type as PieceSymbol, color: color as Color }\r\n\r\n    if (type === KING) {\r\n      this._kings[color] = sq\r\n    }\r\n\r\n    this._updateCastlingRights()\r\n    this._updateEnPassantSquare()\r\n    this._updateSetup(this.fen())\r\n\r\n    return true\r\n  }\r\n\r\n  remove(square: Square) {\r\n    const piece = this.get(square)\r\n    delete this._board[Ox88[square]]\r\n    if (piece && piece.type === KING) {\r\n      this._kings[piece.color] = EMPTY\r\n    }\r\n\r\n    this._updateCastlingRights()\r\n    this._updateEnPassantSquare()\r\n    this._updateSetup(this.fen())\r\n\r\n    return piece\r\n  }\r\n\r\n  _updateCastlingRights() {\r\n    const whiteKingInPlace = (this._board[Ox88.e1]?.type === KING && this._board[Ox88.e1]?.color === WHITE)\r\n    const blackKingInPlace = (this._board[Ox88.e8]?.type === KING && this._board[Ox88.e8]?.color === BLACK)\r\n\r\n    if (!whiteKingInPlace || this._board[Ox88.a1]?.type !== ROOK || this._board[Ox88.a1]?.color !== WHITE) {\r\n      this._castling.w &= ~BITS.QSIDE_CASTLE\r\n    }\r\n\r\n    if (!whiteKingInPlace || this._board[Ox88.h1]?.type !== ROOK || this._board[Ox88.h1]?.color !== WHITE) {\r\n      this._castling.w &= ~BITS.KSIDE_CASTLE\r\n    }\r\n\r\n    if (!blackKingInPlace || this._board[Ox88.a8]?.type !== ROOK || this._board[Ox88.a8]?.color !== BLACK) {\r\n      this._castling.b &= ~BITS.QSIDE_CASTLE\r\n    }\r\n\r\n    if (!blackKingInPlace || this._board[Ox88.h8]?.type !== ROOK || this._board[Ox88.h8]?.color !== BLACK) {\r\n      this._castling.b &= ~BITS.KSIDE_CASTLE\r\n    }\r\n  }\r\n\r\n  _updateEnPassantSquare() {\r\n    if(this._epSquare === EMPTY) {\r\n      return\r\n    }\r\n\r\n    const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16)\r\n    const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\r\n    const attackers = [currentSquare + 1, currentSquare - 1]\r\n\r\n    if (\r\n      this._board[startSquare] !== null ||\r\n      this._board[this._epSquare] !== null ||\r\n      this._board[currentSquare]?.color !== swapColor(this._turn) ||\r\n      this._board[currentSquare]?.type !== PAWN\r\n    ) {\r\n      this._epSquare = EMPTY\r\n      return\r\n    }\r\n\r\n    const canCapture = (square: number) =>\r\n      !(square & 0x88) &&\r\n      this._board[square]?.color === this._turn &&\r\n      this._board[square]?.type === PAWN;\r\n\r\n    if(!attackers.some(canCapture)) {\r\n      this._epSquare = EMPTY\r\n    }\r\n  }\r\n\r\n  _attacked(color: Color, square: number) {\r\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n      // did we run off the end of the board\r\n      if (i & 0x88) {\r\n        i += 7\r\n        continue\r\n      }\r\n\r\n      // if empty square or wrong color\r\n      if (this._board[i] === undefined || this._board[i].color !== color) {\r\n        continue\r\n      }\r\n\r\n      const piece = this._board[i]\r\n      const difference = i - square\r\n\r\n      // skip - to/from square are the same\r\n      if (difference === 0) {\r\n        continue\r\n      }\r\n\r\n      const index = difference + 119\r\n\r\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\r\n        if (piece.type === PAWN) {\r\n          if (difference > 0) {\r\n            if (piece.color === WHITE) return true\r\n          } else {\r\n            if (piece.color === BLACK) return true\r\n          }\r\n          continue\r\n        }\r\n\r\n        // if the piece is a knight or a king\r\n        if (piece.type === 'n' || piece.type === 'k') return true\r\n\r\n        const offset = RAYS[index]\r\n        let j = i + offset\r\n\r\n        let blocked = false\r\n        while (j !== square) {\r\n          if (this._board[j] != null) {\r\n            blocked = true\r\n            break\r\n          }\r\n          j += offset\r\n        }\r\n\r\n        if (!blocked) return true\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  private _isKingAttacked(color: Color) {\r\n    const square = this._kings[color]\r\n    return square === -1 ? false : this._attacked(swapColor(color), square)\r\n  }\r\n\r\n  isAttacked(square: Square, attackedBy: Color) {\r\n    return this._attacked(attackedBy, Ox88[square])\r\n  }\r\n\r\n  isCheck() {\r\n    return this._isKingAttacked(this._turn)\r\n  }\r\n\r\n  inCheck() {\r\n    return this.isCheck()\r\n  }\r\n\r\n  isCheckmate() {\r\n    return this.isCheck() && this._moves().length === 0\r\n  }\r\n\r\n  isStalemate() {\r\n    return !this.isCheck() && this._moves().length === 0\r\n  }\r\n\r\n  isInsufficientMaterial() {\r\n    /*\r\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\r\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\r\n     *\r\n     * k.b. vs k.n. with mate in 1:\r\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\r\n     */\r\n    const pieces: Record<PieceSymbol, number> = {\r\n      b: 0,\r\n      n: 0,\r\n      r: 0,\r\n      q: 0,\r\n      k: 0,\r\n      p: 0,\r\n    }\r\n    const bishops = []\r\n    let numPieces = 0\r\n    let squareColor = 0\r\n\r\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n      squareColor = (squareColor + 1) % 2\r\n      if (i & 0x88) {\r\n        i += 7\r\n        continue\r\n      }\r\n\r\n      const piece = this._board[i]\r\n      if (piece) {\r\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\r\n        if (piece.type === BISHOP) {\r\n          bishops.push(squareColor)\r\n        }\r\n        numPieces++\r\n      }\r\n    }\r\n\r\n    // k vs. k\r\n    if (numPieces === 2) {\r\n      return true\r\n    } else if (\r\n      // k vs. kn .... or .... k vs. kb\r\n      numPieces === 3 &&\r\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\r\n    ) {\r\n      return true\r\n    } else if (numPieces === pieces[BISHOP] + 2) {\r\n      // kb vs. kb where any number of bishops are all on the same color\r\n      let sum = 0\r\n      const len = bishops.length\r\n      for (let i = 0; i < len; i++) {\r\n        sum += bishops[i]\r\n      }\r\n      if (sum === 0 || sum === len) {\r\n        return true\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  isThreefoldRepetition() {\r\n    const moves = []\r\n    const positions: Record<string, number> = {}\r\n    let repetition = false\r\n\r\n    while (true) {\r\n      const move = this._undoMove()\r\n      if (!move) break\r\n      moves.push(move)\r\n    }\r\n\r\n    while (true) {\r\n      /*\r\n       * remove the last two fields in the FEN string, they're not needed when\r\n       * checking for draw by rep\r\n       */\r\n      const fen = this.fen().split(' ').slice(0, 4).join(' ')\r\n\r\n      // has the position occurred three or move times\r\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1\r\n      if (positions[fen] >= 3) {\r\n        repetition = true\r\n      }\r\n\r\n      const move = moves.pop()\r\n\r\n      if (!move) {\r\n        break\r\n      } else {\r\n        this._makeMove(move)\r\n      }\r\n    }\r\n\r\n    return repetition\r\n  }\r\n\r\n  isDraw() {\r\n    return (\r\n      this._halfMoves >= 100 || // 50 moves per side = 100 half moves\r\n      this.isStalemate() ||\r\n      this.isInsufficientMaterial() ||\r\n      this.isThreefoldRepetition()\r\n    )\r\n  }\r\n\r\n  isGameOver() {\r\n    return this.isCheckmate() || this.isStalemate() || this.isDraw()\r\n  }\r\n\r\n  moves(): string[]\r\n  moves({ square }: { square: Square }): string[]\r\n  moves({ piece }: { piece: PieceSymbol }): string[]\r\n\r\n  moves({ square, piece }: { square: Square; piece: PieceSymbol }): string[]\r\n\r\n  moves({ verbose, square }: { verbose: true; square?: Square }): Move[]\r\n  moves({ verbose, square }: { verbose: false; square?: Square }): string[]\r\n  moves({\r\n    verbose,\r\n    square,\r\n  }: {\r\n    verbose?: boolean\r\n    square?: Square\r\n  }): string[] | Move[]\r\n\r\n  moves({ verbose, piece }: { verbose: true; piece?: PieceSymbol }): Move[]\r\n  moves({ verbose, piece }: { verbose: false; piece?: PieceSymbol }): string[]\r\n  moves({\r\n    verbose,\r\n    piece,\r\n  }: {\r\n    verbose?: boolean\r\n    piece?: PieceSymbol\r\n  }): string[] | Move[]\r\n\r\n  moves({\r\n    verbose,\r\n    square,\r\n    piece,\r\n  }: {\r\n    verbose: true\r\n    square?: Square\r\n    piece?: PieceSymbol\r\n  }): Move[]\r\n  moves({\r\n    verbose,\r\n    square,\r\n    piece,\r\n  }: {\r\n    verbose: false\r\n    square?: Square\r\n    piece?: PieceSymbol\r\n  }): string[]\r\n  moves({\r\n    verbose,\r\n    square,\r\n    piece,\r\n  }: {\r\n    verbose?: boolean\r\n    square?: Square\r\n    piece?: PieceSymbol\r\n  }): string[] | Move[]\r\n\r\n  moves({ square, piece }: { square?: Square; piece?: PieceSymbol }): Move[]\r\n\r\n  moves({\r\n    verbose = false,\r\n    square = undefined,\r\n    piece = undefined,\r\n  }: { verbose?: boolean; square?: Square; piece?: PieceSymbol } = {}) {\r\n    const moves = this._moves({ square, piece })\r\n\r\n    if (verbose) {\r\n      return moves.map((move) => this._makePretty(move))\r\n    } else {\r\n      return moves.map((move) => this._moveToSan(move, moves))\r\n    }\r\n  }\r\n\r\n  _moves({\r\n    legal = true,\r\n    piece = undefined,\r\n    square = undefined,\r\n  }: {\r\n    legal?: boolean\r\n    piece?: PieceSymbol\r\n    square?: Square\r\n  } = {}) {\r\n    const forSquare = square ? (square.toLowerCase() as Square) : undefined\r\n    const forPiece = piece?.toLowerCase()\r\n\r\n    const moves: InternalMove[] = []\r\n    const us = this._turn\r\n    const them = swapColor(us)\r\n\r\n    let firstSquare = Ox88.a8\r\n    let lastSquare = Ox88.h1\r\n    let singleSquare = false\r\n\r\n    // are we generating moves for a single square?\r\n    if (forSquare) {\r\n      // illegal square, return empty moves\r\n      if (!(forSquare in Ox88)) {\r\n        return []\r\n      } else {\r\n        firstSquare = lastSquare = Ox88[forSquare]\r\n        singleSquare = true\r\n      }\r\n    }\r\n\r\n    for (let from = firstSquare; from <= lastSquare; from++) {\r\n      // did we run off the end of the board\r\n      if (from & 0x88) {\r\n        from += 7\r\n        continue\r\n      }\r\n\r\n      // empty square or opponent, skip\r\n      if (!this._board[from] || this._board[from].color === them) {\r\n        continue\r\n      }\r\n      const { type } = this._board[from]\r\n\r\n      let to: number\r\n      if (type === PAWN) {\r\n        if (forPiece && forPiece !== type) continue\r\n\r\n        // single square, non-capturing\r\n        to = from + PAWN_OFFSETS[us][0]\r\n        if (!this._board[to]) {\r\n          addMove(moves, us, from, to, PAWN)\r\n\r\n          // double square\r\n          to = from + PAWN_OFFSETS[us][1]\r\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\r\n            addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN)\r\n          }\r\n        }\r\n\r\n        // pawn captures\r\n        for (let j = 2; j < 4; j++) {\r\n          to = from + PAWN_OFFSETS[us][j]\r\n          if (to & 0x88) continue\r\n\r\n          if (this._board[to]?.color === them) {\r\n            addMove(\r\n              moves,\r\n              us,\r\n              from,\r\n              to,\r\n              PAWN,\r\n              this._board[to].type,\r\n              BITS.CAPTURE\r\n            )\r\n          } else if (to === this._epSquare) {\r\n            addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE)\r\n          }\r\n        }\r\n      } else {\r\n        if (forPiece && forPiece !== type) continue\r\n\r\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\r\n          const offset = PIECE_OFFSETS[type][j]\r\n          to = from\r\n\r\n          while (true) {\r\n            to += offset\r\n            if (to & 0x88) break\r\n\r\n            if (!this._board[to]) {\r\n              addMove(moves, us, from, to, type)\r\n            } else {\r\n              // own color, stop loop\r\n              if (this._board[to].color === us) break\r\n\r\n              addMove(\r\n                moves,\r\n                us,\r\n                from,\r\n                to,\r\n                type,\r\n                this._board[to].type,\r\n                BITS.CAPTURE\r\n              )\r\n              break\r\n            }\r\n\r\n            /* break, if knight or king */\r\n            if (type === KNIGHT || type === KING) break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /*\r\n     * check for castling if we're:\r\n     *   a) generating all moves, or\r\n     *   b) doing single square move generation on the king's square\r\n     */\r\n\r\n    if (forPiece === undefined || forPiece === KING) {\r\n      if (!singleSquare || lastSquare === this._kings[us]) {\r\n        // king-side castling\r\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\r\n          const castlingFrom = this._kings[us]\r\n          const castlingTo = castlingFrom + 2\r\n\r\n          if (\r\n            !this._board[castlingFrom + 1] &&\r\n            !this._board[castlingTo] &&\r\n            !this._attacked(them, this._kings[us]) &&\r\n            !this._attacked(them, castlingFrom + 1) &&\r\n            !this._attacked(them, castlingTo)\r\n          ) {\r\n            addMove(\r\n              moves,\r\n              us,\r\n              this._kings[us],\r\n              castlingTo,\r\n              KING,\r\n              undefined,\r\n              BITS.KSIDE_CASTLE\r\n            )\r\n          }\r\n        }\r\n\r\n        // queen-side castling\r\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\r\n          const castlingFrom = this._kings[us]\r\n          const castlingTo = castlingFrom - 2\r\n\r\n          if (\r\n            !this._board[castlingFrom - 1] &&\r\n            !this._board[castlingFrom - 2] &&\r\n            !this._board[castlingFrom - 3] &&\r\n            !this._attacked(them, this._kings[us]) &&\r\n            !this._attacked(them, castlingFrom - 1) &&\r\n            !this._attacked(them, castlingTo)\r\n          ) {\r\n            addMove(\r\n              moves,\r\n              us,\r\n              this._kings[us],\r\n              castlingTo,\r\n              KING,\r\n              undefined,\r\n              BITS.QSIDE_CASTLE\r\n            )\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /*\r\n     * return all pseudo-legal moves (this includes moves that allow the king\r\n     * to be captured)\r\n     */\r\n    if (!legal || this._kings[us] === -1) {\r\n      return moves\r\n    }\r\n\r\n    // filter out illegal moves\r\n    const legalMoves = []\r\n\r\n    for (let i = 0, len = moves.length; i < len; i++) {\r\n      this._makeMove(moves[i])\r\n      if (!this._isKingAttacked(us)) {\r\n        legalMoves.push(moves[i])\r\n      }\r\n      this._undoMove()\r\n    }\r\n\r\n    return legalMoves\r\n  }\r\n\r\n  move(\r\n    move: string | { from: string; to: string; promotion?: string },\r\n    { strict = false }: { strict?: boolean } = {}\r\n  ) {\r\n    /*\r\n     * The move function can be called with in the following parameters:\r\n     *\r\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\r\n     *\r\n     * .move({ from: 'h7', <- argument is a move object\r\n     *         to :'h8',\r\n     *         promotion: 'q' })\r\n     *\r\n     *\r\n     * An optional strict argument may be supplied to tell chess.js to\r\n     * strictly follow the SAN specification.\r\n     */\r\n\r\n    let moveObj = null\r\n\r\n    if (typeof move === 'string') {\r\n      moveObj = this._moveFromSan(move, strict)\r\n    } else if (typeof move === 'object') {\r\n      const moves = this._moves()\r\n\r\n      // convert the pretty move object to an ugly move object\r\n      for (let i = 0, len = moves.length; i < len; i++) {\r\n        if (\r\n          move.from === algebraic(moves[i].from) &&\r\n          move.to === algebraic(moves[i].to) &&\r\n          (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)\r\n        ) {\r\n          moveObj = moves[i]\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    // failed to find move\r\n    if (!moveObj) {\r\n      if (typeof move === 'string') {\r\n        throw new Error(`Invalid move: ${move}`)\r\n      } else {\r\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`)\r\n      }\r\n    }\r\n\r\n    /*\r\n     * need to make a copy of move because we can't generate SAN after the move\r\n     * is made\r\n     */\r\n    const prettyMove = this._makePretty(moveObj)\r\n\r\n    this._makeMove(moveObj)\r\n\r\n    return prettyMove\r\n  }\r\n\r\n  _push(move: InternalMove) {\r\n    this._history.push({\r\n      move,\r\n      kings: { b: this._kings.b, w: this._kings.w },\r\n      turn: this._turn,\r\n      castling: { b: this._castling.b, w: this._castling.w },\r\n      epSquare: this._epSquare,\r\n      halfMoves: this._halfMoves,\r\n      moveNumber: this._moveNumber,\r\n    })\r\n  }\r\n\r\n  private _makeMove(move: InternalMove) {\r\n    const us = this._turn\r\n    const them = swapColor(us)\r\n    this._push(move)\r\n\r\n    this._board[move.to] = this._board[move.from]\r\n    delete this._board[move.from]\r\n\r\n    // if ep capture, remove the captured pawn\r\n    if (move.flags & BITS.EP_CAPTURE) {\r\n      if (this._turn === BLACK) {\r\n        delete this._board[move.to - 16]\r\n      } else {\r\n        delete this._board[move.to + 16]\r\n      }\r\n    }\r\n\r\n    // if pawn promotion, replace with new piece\r\n    if (move.promotion) {\r\n      this._board[move.to] = { type: move.promotion, color: us }\r\n    }\r\n\r\n    // if we moved the king\r\n    if (this._board[move.to].type === KING) {\r\n      this._kings[us] = move.to\r\n\r\n      // if we castled, move the rook next to the king\r\n      if (move.flags & BITS.KSIDE_CASTLE) {\r\n        const castlingTo = move.to - 1\r\n        const castlingFrom = move.to + 1\r\n        this._board[castlingTo] = this._board[castlingFrom]\r\n        delete this._board[castlingFrom]\r\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n        const castlingTo = move.to + 1\r\n        const castlingFrom = move.to - 2\r\n        this._board[castlingTo] = this._board[castlingFrom]\r\n        delete this._board[castlingFrom]\r\n      }\r\n\r\n      // turn off castling\r\n      this._castling[us] = 0\r\n    }\r\n\r\n    // turn off castling if we move a rook\r\n    if (this._castling[us]) {\r\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\r\n        if (\r\n          move.from === ROOKS[us][i].square &&\r\n          this._castling[us] & ROOKS[us][i].flag\r\n        ) {\r\n          this._castling[us] ^= ROOKS[us][i].flag\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    // turn off castling if we capture a rook\r\n    if (this._castling[them]) {\r\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\r\n        if (\r\n          move.to === ROOKS[them][i].square &&\r\n          this._castling[them] & ROOKS[them][i].flag\r\n        ) {\r\n          this._castling[them] ^= ROOKS[them][i].flag\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    // if big pawn move, update the en passant square\r\n    if (move.flags & BITS.BIG_PAWN) {\r\n      if (us === BLACK) {\r\n        this._epSquare = move.to - 16\r\n      } else {\r\n        this._epSquare = move.to + 16\r\n      }\r\n    } else {\r\n      this._epSquare = EMPTY\r\n    }\r\n\r\n    // reset the 50 move counter if a pawn is moved or a piece is captured\r\n    if (move.piece === PAWN) {\r\n      this._halfMoves = 0\r\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\r\n      this._halfMoves = 0\r\n    } else {\r\n      this._halfMoves++\r\n    }\r\n\r\n    if (us === BLACK) {\r\n      this._moveNumber++\r\n    }\r\n\r\n    this._turn = them\r\n  }\r\n\r\n  undo() {\r\n    const move = this._undoMove()\r\n    return move ? this._makePretty(move) : null\r\n  }\r\n\r\n  private _undoMove() {\r\n    const old = this._history.pop()\r\n    if (old === undefined) {\r\n      return null\r\n    }\r\n\r\n    const move = old.move\r\n\r\n    this._kings = old.kings\r\n    this._turn = old.turn\r\n    this._castling = old.castling\r\n    this._epSquare = old.epSquare\r\n    this._halfMoves = old.halfMoves\r\n    this._moveNumber = old.moveNumber\r\n\r\n    const us = this._turn\r\n    const them = swapColor(us)\r\n\r\n    this._board[move.from] = this._board[move.to]\r\n    this._board[move.from].type = move.piece // to undo any promotions\r\n    delete this._board[move.to]\r\n\r\n    if (move.captured) {\r\n      if (move.flags & BITS.EP_CAPTURE) {\r\n        // en passant capture\r\n        let index: number\r\n        if (us === BLACK) {\r\n          index = move.to - 16\r\n        } else {\r\n          index = move.to + 16\r\n        }\r\n        this._board[index] = { type: PAWN, color: them }\r\n      } else {\r\n        // regular capture\r\n        this._board[move.to] = { type: move.captured, color: them }\r\n      }\r\n    }\r\n\r\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\r\n      let castlingTo: number, castlingFrom: number\r\n      if (move.flags & BITS.KSIDE_CASTLE) {\r\n        castlingTo = move.to + 1\r\n        castlingFrom = move.to - 1\r\n      } else {\r\n        castlingTo = move.to - 2\r\n        castlingFrom = move.to + 1\r\n      }\r\n\r\n      this._board[castlingTo] = this._board[castlingFrom]\r\n      delete this._board[castlingFrom]\r\n    }\r\n\r\n    return move\r\n  }\r\n\r\n  pgn({\r\n    newline = '\\n',\r\n    maxWidth = 0,\r\n  }: { newline?: string; maxWidth?: number } = {}) {\r\n    /*\r\n     * using the specification from http://www.chessclub.com/help/PGN-spec\r\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\r\n     */\r\n\r\n    const result: string[] = []\r\n    let headerExists = false\r\n\r\n    /* add the PGN header information */\r\n    for (const i in this._header) {\r\n      /*\r\n       * TODO: order of enumerated properties in header object is not\r\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\r\n       */\r\n      result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline)\r\n      headerExists = true\r\n    }\r\n\r\n    if (headerExists && this._history.length) {\r\n      result.push(newline)\r\n    }\r\n\r\n    const appendComment = (moveString: string) => {\r\n      const comment = this._comments[this.fen()]\r\n      if (typeof comment !== 'undefined') {\r\n        const delimiter = moveString.length > 0 ? ' ' : ''\r\n        moveString = `${moveString}${delimiter}{${comment}}`\r\n      }\r\n      return moveString\r\n    }\r\n\r\n    // pop all of history onto reversed_history\r\n    const reversedHistory = []\r\n    while (this._history.length > 0) {\r\n      reversedHistory.push(this._undoMove())\r\n    }\r\n\r\n    const moves = []\r\n    let moveString = ''\r\n\r\n    // special case of a commented starting position with no moves\r\n    if (reversedHistory.length === 0) {\r\n      moves.push(appendComment(''))\r\n    }\r\n\r\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\r\n    while (reversedHistory.length > 0) {\r\n      moveString = appendComment(moveString)\r\n      const move = reversedHistory.pop()\r\n\r\n      // make TypeScript stop complaining about move being undefined\r\n      if (!move) {\r\n        break\r\n      }\r\n\r\n      // if the position started with black to move, start PGN with #. ...\r\n      if (!this._history.length && move.color === 'b') {\r\n        const prefix = `${this._moveNumber}. ...`\r\n        // is there a comment preceding the first move?\r\n        moveString = moveString ? `${moveString} ${prefix}` : prefix\r\n      } else if (move.color === 'w') {\r\n        // store the previous generated move_string if we have one\r\n        if (moveString.length) {\r\n          moves.push(moveString)\r\n        }\r\n        moveString = this._moveNumber + '.'\r\n      }\r\n\r\n      moveString =\r\n        moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }))\r\n      this._makeMove(move)\r\n    }\r\n\r\n    // are there any other leftover moves?\r\n    if (moveString.length) {\r\n      moves.push(appendComment(moveString))\r\n    }\r\n\r\n    // is there a result?\r\n    if (typeof this._header.Result !== 'undefined') {\r\n      moves.push(this._header.Result)\r\n    }\r\n\r\n    /*\r\n     * history should be back to what it was before we started generating PGN,\r\n     * so join together moves\r\n     */\r\n    if (maxWidth === 0) {\r\n      return result.join('') + moves.join(' ')\r\n    }\r\n\r\n    // TODO (jah): huh?\r\n    const strip = function () {\r\n      if (result.length > 0 && result[result.length - 1] === ' ') {\r\n        result.pop()\r\n        return true\r\n      }\r\n      return false\r\n    }\r\n\r\n    // NB: this does not preserve comment whitespace.\r\n    const wrapComment = function (width: number, move: string) {\r\n      for (const token of move.split(' ')) {\r\n        if (!token) {\r\n          continue\r\n        }\r\n        if (width + token.length > maxWidth) {\r\n          while (strip()) {\r\n            width--\r\n          }\r\n          result.push(newline)\r\n          width = 0\r\n        }\r\n        result.push(token)\r\n        width += token.length\r\n        result.push(' ')\r\n        width++\r\n      }\r\n      if (strip()) {\r\n        width--\r\n      }\r\n      return width\r\n    }\r\n\r\n    // wrap the PGN output at max_width\r\n    let currentWidth = 0\r\n    for (let i = 0; i < moves.length; i++) {\r\n      if (currentWidth + moves[i].length > maxWidth) {\r\n        if (moves[i].includes('{')) {\r\n          currentWidth = wrapComment(currentWidth, moves[i])\r\n          continue\r\n        }\r\n      }\r\n      // if the current move will push past max_width\r\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\r\n        // don't end the line with whitespace\r\n        if (result[result.length - 1] === ' ') {\r\n          result.pop()\r\n        }\r\n\r\n        result.push(newline)\r\n        currentWidth = 0\r\n      } else if (i !== 0) {\r\n        result.push(' ')\r\n        currentWidth++\r\n      }\r\n      result.push(moves[i])\r\n      currentWidth += moves[i].length\r\n    }\r\n\r\n    return result.join('')\r\n  }\r\n\r\n  header(...args: string[]) {\r\n    for (let i = 0; i < args.length; i += 2) {\r\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\r\n        this._header[args[i]] = args[i + 1]\r\n      }\r\n    }\r\n    return this._header\r\n  }\r\n\r\n  loadPgn(\r\n    pgn: string,\r\n    {\r\n      strict = false,\r\n      newlineChar = '\\r?\\n',\r\n    }: { strict?: boolean; newlineChar?: string } = {}\r\n  ) {\r\n    function mask(str: string): string {\r\n      return str.replace(/\\\\/g, '\\\\')\r\n    }\r\n\r\n    function parsePgnHeader(header: string): { [key: string]: string } {\r\n      const headerObj: Record<string, string> = {}\r\n      const headers = header.split(new RegExp(mask(newlineChar)))\r\n      let key = ''\r\n      let value = ''\r\n\r\n      for (let i = 0; i < headers.length; i++) {\r\n        const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/\r\n        key = headers[i].replace(regex, '$1')\r\n        value = headers[i].replace(regex, '$2')\r\n        if (key.trim().length > 0) {\r\n          headerObj[key] = value\r\n        }\r\n      }\r\n\r\n      return headerObj\r\n    }\r\n\r\n    // strip whitespace from head/tail of PGN block\r\n    pgn = pgn.trim()\r\n\r\n    /*\r\n     * RegExp to split header. Takes advantage of the fact that header and movetext\r\n     * will always have a blank line between them (ie, two newline_char's). Handles\r\n     * case where movetext is empty by matching newlineChar until end of string is\r\n     * matched - effectively trimming from the end extra newlineChar.\r\n     *\r\n     * With default newline_char, will equal:\r\n     * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\r\n     */\r\n    const headerRegex = new RegExp(\r\n      '^(\\\\[((?:' +\r\n        mask(newlineChar) +\r\n        ')|.)*\\\\])' +\r\n        '((?:\\\\s*' +\r\n        mask(newlineChar) +\r\n        '){2}|(?:\\\\s*' +\r\n        mask(newlineChar) +\r\n        ')*$)'\r\n    )\r\n\r\n    // If no header given, begin with moves.\r\n    const headerRegexResults = headerRegex.exec(pgn)\r\n    const headerString = headerRegexResults\r\n      ? headerRegexResults.length >= 2\r\n        ? headerRegexResults[1]\r\n        : ''\r\n      : ''\r\n\r\n    // Put the board in the starting position\r\n    this.reset()\r\n\r\n    // parse PGN header\r\n    const headers = parsePgnHeader(headerString)\r\n    let fen = ''\r\n\r\n    for (const key in headers) {\r\n      // check to see user is including fen (possibly with wrong tag case)\r\n      if (key.toLowerCase() === 'fen') {\r\n        fen = headers[key]\r\n      }\r\n\r\n      this.header(key, headers[key])\r\n    }\r\n\r\n    /*\r\n     * the permissive parser should attempt to load a fen tag, even if it's the\r\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\r\n     */\r\n    if (!strict) {\r\n      if (fen) {\r\n        this.load(fen, true)\r\n      }\r\n    } else {\r\n      /*\r\n       * strict parser - load the starting position indicated by [Setup '1']\r\n       * and [FEN position]\r\n       */\r\n      if (headers['SetUp'] === '1') {\r\n        if (!('FEN' in headers)) {\r\n          throw new Error(\r\n            'Invalid PGN: FEN tag must be supplied with SetUp tag'\r\n          )\r\n        }\r\n        // second argument to load: don't clear the headers\r\n        this.load(headers['FEN'], true)\r\n      }\r\n    }\r\n\r\n    /*\r\n     * NB: the regexes below that delete move numbers, recursive annotations,\r\n     * and numeric annotation glyphs may also match text in comments. To\r\n     * prevent this, we transform comments by hex-encoding them in place and\r\n     * decoding them again after the other tokens have been deleted.\r\n     *\r\n     * While the spec states that PGN files should be ASCII encoded, we use\r\n     * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\r\n     * for modern users\r\n     */\r\n\r\n    function toHex(s: string): string {\r\n      return Array.from(s)\r\n        .map(function (c) {\r\n          /*\r\n           * encodeURI doesn't transform most ASCII characters, so we handle\r\n           * these ourselves\r\n           */\r\n          return c.charCodeAt(0) < 128\r\n            ? c.charCodeAt(0).toString(16)\r\n            : encodeURIComponent(c).replace(/%/g, '').toLowerCase()\r\n        })\r\n        .join('')\r\n    }\r\n\r\n    function fromHex(s: string): string {\r\n      return s.length == 0\r\n        ? ''\r\n        : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'))\r\n    }\r\n\r\n    const encodeComment = function (s: string) {\r\n      s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ')\r\n      return `{${toHex(s.slice(1, s.length - 1))}}`\r\n    }\r\n\r\n    const decodeComment = function (s: string) {\r\n      if (s.startsWith('{') && s.endsWith('}')) {\r\n        return fromHex(s.slice(1, s.length - 1))\r\n      }\r\n    }\r\n\r\n    // delete header to get the moves\r\n    let ms = pgn\r\n      .replace(headerString, '')\r\n      .replace(\r\n        // encode comments so they don't get deleted below\r\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'),\r\n        function (_match, bracket, semicolon) {\r\n          return bracket !== undefined\r\n            ? encodeComment(bracket)\r\n            : ' ' + encodeComment(`{${semicolon.slice(1)}}`)\r\n        }\r\n      )\r\n      .replace(new RegExp(mask(newlineChar), 'g'), ' ')\r\n\r\n    // delete recursive annotation variations\r\n    const ravRegex = /(\\([^()]+\\))+?/g\r\n    while (ravRegex.test(ms)) {\r\n      ms = ms.replace(ravRegex, '')\r\n    }\r\n\r\n    // delete move numbers\r\n    ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\r\n\r\n    // delete ... indicating black to move\r\n    ms = ms.replace(/\\.\\.\\./g, '')\r\n\r\n    /* delete numeric annotation glyphs */\r\n    ms = ms.replace(/\\$\\d+/g, '')\r\n\r\n    // trim and get array of moves\r\n    let moves = ms.trim().split(new RegExp(/\\s+/))\r\n\r\n    // delete empty entries\r\n    moves = moves.filter((move) => move !== '')\r\n\r\n    let result = ''\r\n\r\n    for (let halfMove = 0; halfMove < moves.length; halfMove++) {\r\n      const comment = decodeComment(moves[halfMove])\r\n      if (comment !== undefined) {\r\n        this._comments[this.fen()] = comment\r\n        continue\r\n      }\r\n\r\n      const move = this._moveFromSan(moves[halfMove], strict)\r\n\r\n      // invalid move\r\n      if (move == null) {\r\n        // was the move an end of game marker\r\n        if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\r\n          result = moves[halfMove]\r\n        } else {\r\n          throw new Error(`Invalid move in PGN: ${moves[halfMove]}`)\r\n        }\r\n      } else {\r\n        // reset the end of game marker if making a valid move\r\n        result = ''\r\n        this._makeMove(move)\r\n      }\r\n    }\r\n\r\n    /*\r\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\r\n     * the termination marker. Only do this when headers are present, but the\r\n     * result tag is missing\r\n     */\r\n\r\n    if (result && Object.keys(this._header).length && !this._header['Result']) {\r\n      this.header('Result', result)\r\n    }\r\n  }\r\n\r\n  /*\r\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\r\n   * (SAN)\r\n   *\r\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\r\n   * on overly disambiguated moves (see below):\r\n   *\r\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\r\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\r\n   * 4. ... Ne7 is technically the valid SAN\r\n   */\r\n\r\n  private _moveToSan(move: InternalMove, moves: InternalMove[]) {\r\n    let output = ''\r\n\r\n    if (move.flags & BITS.KSIDE_CASTLE) {\r\n      output = 'O-O'\r\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n      output = 'O-O-O'\r\n    } else {\r\n      if (move.piece !== PAWN) {\r\n        const disambiguator = getDisambiguator(move, moves)\r\n        output += move.piece.toUpperCase() + disambiguator\r\n      }\r\n\r\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\r\n        if (move.piece === PAWN) {\r\n          output += algebraic(move.from)[0]\r\n        }\r\n        output += 'x'\r\n      }\r\n\r\n      output += algebraic(move.to)\r\n\r\n      if (move.promotion) {\r\n        output += '=' + move.promotion.toUpperCase()\r\n      }\r\n    }\r\n\r\n    this._makeMove(move)\r\n    if (this.isCheck()) {\r\n      if (this.isCheckmate()) {\r\n        output += '#'\r\n      } else {\r\n        output += '+'\r\n      }\r\n    }\r\n    this._undoMove()\r\n\r\n    return output\r\n  }\r\n\r\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\r\n  private _moveFromSan(move: string, strict = false): InternalMove | null {\r\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\r\n    const cleanMove = strippedSan(move)\r\n\r\n    let pieceType = inferPieceType(cleanMove)\r\n    let moves = this._moves({ legal: true, piece: pieceType })\r\n\r\n    // strict parser\r\n    for (let i = 0, len = moves.length; i < len; i++) {\r\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\r\n        return moves[i]\r\n      }\r\n    }\r\n\r\n    // the strict parser failed\r\n    if (strict) {\r\n      return null\r\n    }\r\n\r\n    let piece = undefined\r\n    let matches = undefined\r\n    let from = undefined\r\n    let to = undefined\r\n    let promotion = undefined\r\n\r\n    /*\r\n     * The default permissive (non-strict) parser allows the user to parse\r\n     * non-standard chess notations. This parser is only run after the strict\r\n     * Standard Algebraic Notation (SAN) parser has failed.\r\n     *\r\n     * When running the permissive parser, we'll run a regex to grab the piece, the\r\n     * to/from square, and an optional promotion piece. This regex will\r\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\r\n     * f7f8q, b1c3\r\n     *\r\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\r\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\r\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\r\n     * move). In these cases, the permissive parser will default to the most\r\n     * basic interpretation (which is b1c3 parsing to Nc3).\r\n     */\r\n\r\n    let overlyDisambiguated = false\r\n\r\n    matches = cleanMove.match(\r\n      /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\r\n      //     piece         from              to       promotion\r\n    )\r\n\r\n    if (matches) {\r\n      piece = matches[1]\r\n      from = matches[2] as Square\r\n      to = matches[3] as Square\r\n      promotion = matches[4]\r\n\r\n      if (from.length == 1) {\r\n        overlyDisambiguated = true\r\n      }\r\n    } else {\r\n      /*\r\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\r\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\r\n       * there is one legal knight move to e7). In this case, the value of\r\n       * 'from' variable will be a rank or file, not a square.\r\n       */\r\n\r\n      matches = cleanMove.match(\r\n        /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/\r\n      )\r\n\r\n      if (matches) {\r\n        piece = matches[1]\r\n        from = matches[2] as Square\r\n        to = matches[3] as Square\r\n        promotion = matches[4]\r\n\r\n        if (from.length == 1) {\r\n          overlyDisambiguated = true\r\n        }\r\n      }\r\n    }\r\n\r\n    pieceType = inferPieceType(cleanMove)\r\n    moves = this._moves({\r\n      legal: true,\r\n      piece: piece ? (piece as PieceSymbol) : pieceType,\r\n    })\r\n\r\n    if (!to) {\r\n      return null;\r\n    }\r\n\r\n    for (let i = 0, len = moves.length; i < len; i++) {\r\n      if (!from) {\r\n          // if there is no from square, it could be just 'x' missing from a capture\r\n          if (cleanMove === strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\r\n            return moves[i];\r\n          }\r\n      // hand-compare move properties with the results from our permissive regex\r\n      } else if (\r\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\r\n          Ox88[from] == moves[i].from &&\r\n          Ox88[to] == moves[i].to &&\r\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\r\n      ) {\r\n        return moves[i]\r\n      } else if (overlyDisambiguated) {\r\n        /*\r\n         * SPECIAL CASE: we parsed a move string that may have an unneeded\r\n         * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\r\n         */\r\n\r\n        const square = algebraic(moves[i].from)\r\n        if (\r\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\r\n          Ox88[to] == moves[i].to &&\r\n          (from == square[0] || from == square[1]) &&\r\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\r\n        ) {\r\n          return moves[i]\r\n        }\r\n      }\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  ascii() {\r\n    let s = '   +------------------------+\\n'\r\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n      // display the rank\r\n      if (file(i) === 0) {\r\n        s += ' ' + '87654321'[rank(i)] + ' |'\r\n      }\r\n\r\n      if (this._board[i]) {\r\n        const piece = this._board[i].type\r\n        const color = this._board[i].color\r\n        const symbol =\r\n          color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\r\n        s += ' ' + symbol + ' '\r\n      } else {\r\n        s += ' . '\r\n      }\r\n\r\n      if ((i + 1) & 0x88) {\r\n        s += '|\\n'\r\n        i += 8\r\n      }\r\n    }\r\n    s += '   +------------------------+\\n'\r\n    s += '     a  b  c  d  e  f  g  h'\r\n\r\n    return s\r\n  }\r\n\r\n  perft(depth: number) {\r\n    const moves = this._moves({ legal: false })\r\n    let nodes = 0\r\n    const color = this._turn\r\n\r\n    for (let i = 0, len = moves.length; i < len; i++) {\r\n      this._makeMove(moves[i])\r\n      if (!this._isKingAttacked(color)) {\r\n        if (depth - 1 > 0) {\r\n          nodes += this.perft(depth - 1)\r\n        } else {\r\n          nodes++\r\n        }\r\n      }\r\n      this._undoMove()\r\n    }\r\n\r\n    return nodes\r\n  }\r\n\r\n  // pretty = external move object\r\n  private _makePretty(uglyMove: InternalMove): Move {\r\n    const { color, piece, from, to, flags, captured, promotion } = uglyMove\r\n\r\n    let prettyFlags = ''\r\n\r\n    for (const flag in BITS) {\r\n      if (BITS[flag] & flags) {\r\n        prettyFlags += FLAGS[flag]\r\n      }\r\n    }\r\n\r\n    const fromAlgebraic = algebraic(from)\r\n    const toAlgebraic = algebraic(to)\r\n\r\n    const move: Move = {\r\n      color,\r\n      piece,\r\n      from: fromAlgebraic,\r\n      to: toAlgebraic,\r\n      san: this._moveToSan(uglyMove, this._moves({ legal: true })),\r\n      flags: prettyFlags,\r\n      lan: fromAlgebraic + toAlgebraic,\r\n      before: this.fen(),\r\n      after: '',\r\n    }\r\n\r\n    // generate the FEN for the 'after' key\r\n    this._makeMove(uglyMove)\r\n    move.after = this.fen()\r\n    this._undoMove()\r\n\r\n    if (captured) {\r\n      move.captured = captured\r\n    }\r\n    if (promotion) {\r\n      move.promotion = promotion\r\n      move.lan += promotion\r\n    }\r\n\r\n    return move\r\n  }\r\n\r\n  turn() {\r\n    return this._turn\r\n  }\r\n\r\n  board() {\r\n    const output = []\r\n    let row = []\r\n\r\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n      if (this._board[i] == null) {\r\n        row.push(null)\r\n      } else {\r\n        row.push({\r\n          square: algebraic(i),\r\n          type: this._board[i].type,\r\n          color: this._board[i].color,\r\n        })\r\n      }\r\n      if ((i + 1) & 0x88) {\r\n        output.push(row)\r\n        row = []\r\n        i += 8\r\n      }\r\n    }\r\n\r\n    return output\r\n  }\r\n\r\n  squareColor(square: Square) {\r\n    if (square in Ox88) {\r\n      const sq = Ox88[square]\r\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark'\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  history(): string[]\r\n  history({ verbose }: { verbose: true }): Move[]\r\n  history({ verbose }: { verbose: false }): string[]\r\n  history({ verbose }: { verbose: boolean }): string[] | Move[]\r\n  history({ verbose = false }: { verbose?: boolean } = {}) {\r\n    const reversedHistory = []\r\n    const moveHistory = []\r\n\r\n    while (this._history.length > 0) {\r\n      reversedHistory.push(this._undoMove())\r\n    }\r\n\r\n    while (true) {\r\n      const move = reversedHistory.pop()\r\n      if (!move) {\r\n        break\r\n      }\r\n\r\n      if (verbose) {\r\n        moveHistory.push(this._makePretty(move))\r\n      } else {\r\n        moveHistory.push(this._moveToSan(move, this._moves()))\r\n      }\r\n      this._makeMove(move)\r\n    }\r\n\r\n    return moveHistory\r\n  }\r\n\r\n  private _pruneComments() {\r\n    const reversedHistory = []\r\n    const currentComments: Record<string, string> = {}\r\n\r\n    const copyComment = (fen: string) => {\r\n      if (fen in this._comments) {\r\n        currentComments[fen] = this._comments[fen]\r\n      }\r\n    }\r\n\r\n    while (this._history.length > 0) {\r\n      reversedHistory.push(this._undoMove())\r\n    }\r\n\r\n    copyComment(this.fen())\r\n\r\n    while (true) {\r\n      const move = reversedHistory.pop()\r\n      if (!move) {\r\n        break\r\n      }\r\n      this._makeMove(move)\r\n      copyComment(this.fen())\r\n    }\r\n    this._comments = currentComments\r\n  }\r\n\r\n  getComment() {\r\n    return this._comments[this.fen()]\r\n  }\r\n\r\n  setComment(comment: string) {\r\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']')\r\n  }\r\n\r\n  deleteComment() {\r\n    const comment = this._comments[this.fen()]\r\n    delete this._comments[this.fen()]\r\n    return comment\r\n  }\r\n\r\n  getComments() {\r\n    this._pruneComments()\r\n    return Object.keys(this._comments).map((fen: string) => {\r\n      return { fen: fen, comment: this._comments[fen] }\r\n    })\r\n  }\r\n\r\n  deleteComments() {\r\n    this._pruneComments()\r\n    return Object.keys(this._comments).map((fen) => {\r\n      const comment = this._comments[fen]\r\n      delete this._comments[fen]\r\n      return { fen: fen, comment: comment }\r\n    })\r\n  }\r\n\r\n  setCastlingRights(color: Color, rights: Partial<Record<typeof KING | typeof QUEEN, boolean>>) {\r\n    for (const side of [KING, QUEEN] as const) {\r\n      if (rights[side] !== undefined) {\r\n        if (rights[side]) {\r\n          this._castling[color] |= SIDES[side]\r\n        } else {\r\n          this._castling[color] &= ~SIDES[side]\r\n        }\r\n      }\r\n    }\r\n\r\n    this._updateCastlingRights()\r\n    const result = this.getCastlingRights(color)\r\n\r\n    return (rights[KING] === undefined || rights[KING] === result[KING]) && (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN])\r\n  }\r\n\r\n  getCastlingRights(color: Color) {\r\n    return {\r\n      [KING]: (this._castling[color] & SIDES[KING]) !== 0,\r\n      [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\r\n    }\r\n  }\r\n\r\n  moveNumber() {\r\n    return this._moveNumber\r\n  }\r\n}\r\n"],"mappings":"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E,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAChD,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAG,CAAC,EAAE,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EACjD,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,CAC/C;AAED;AACA,MAAMC,IAAI,GAAG,CACV,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAE,CAAC,EAC5D,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAG,CAAC,CAAC,EAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAC,CAAC,EAAE,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAE,CAAC,EAC9D,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}